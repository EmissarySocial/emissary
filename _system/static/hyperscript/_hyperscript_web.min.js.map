{"version":3,"file":"_hyperscript_web.min.js","sources":["../src/lib/utils.js","../src/lib/core.js","../src/lib/web.js","../src/web/_hyperscript_web.js"],"sourcesContent":["\n/**\n * mergeObjects combines the keys from obj2 into obj2, then returns obj1\n *\n * @param {object} obj1\n * @param {object} obj2\n * @returns object\n */\nexport function mergeObjects(obj1, obj2) {\n\tfor (var key in obj2) {\n\t\tif (obj2.hasOwnProperty(key)) {\n\t\t\tobj1[key] = obj2[key];\n\t\t}\n\t}\n\treturn obj1;\n}\n\nexport function getOrInitObject(root, prop) {\n\tvar value = root[prop];\n\tif (value) {\n\t\treturn value;\n\t} else {\n\t\tvar newObj = {};\n\t\troot[prop] = newObj;\n\t\treturn newObj;\n\t}\n}\n\n/**\n * parseJSON parses a JSON string into a corresponding value.  If the\n * value passed in is not valid JSON, then it logs an error and returns `null`.\n *\n * @param {string} jString\n * @returns any\n */\nexport function parseJSON(jString) {\n\ttry {\n\t\treturn JSON.parse(jString);\n\t} catch (error) {\n\t\tlogError(error);\n\t\treturn null;\n\t}\n}\n\n/**\n * logError writes an error message to the Javascript console.  It can take any\n * value, but msg should commonly be a simple string.\n * @param {*} msg\n */\nexport function logError(msg) {\n\tif (console.error) {\n\t\tconsole.error(msg);\n\t} else if (console.log) {\n\t\tconsole.log(\"ERROR: \", msg);\n\t}\n}\n\n// TODO: JSDoc description of what's happening here\nexport function varargConstructor(Cls, args) {\n\treturn new (Cls.bind.apply(Cls, [Cls].concat(args)))();\n}\n","///=========================================================================\n/// This module provides the core runtime and grammar for hyperscript\n///=========================================================================\n\nimport {getOrInitObject, mergeObjects, parseJSON, varargConstructor} from \"./utils.js\";\n\n\n/**\n * @type {HyperscriptObject}\n */\nlet _hyperscript\n\nvar globalScope = globalThis;\n\n//====================================================================\n// Standard library\n//====================================================================\n\nclass ElementCollection {\n\tconstructor(css, relativeToElement, escape) {\n\t\tthis._css = css;\n\t\tthis.relativeToElement = relativeToElement;\n\t\tthis.escape = escape;\n\t}\n\n\tget css() {\n\t\tif (this.escape) {\n\t\t\treturn _runtime.escapeSelector(this._css);\n\t\t} else {\n\t\t\treturn this._css;\n\t\t}\n\t}\n\n\tget className() {\n\t\treturn this._css.substr(1);\n\t}\n\n\tget id() {\n\t\treturn this.className();\n\t}\n\n\tcontains(elt) {\n\t\tfor (let element of this) {\n\t\t\tif (element.contains(elt)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tget length() {\n\t\treturn this.selectMatches().length;\n\t}\n\n\t[Symbol.iterator]() {\n\t\tlet query = this.selectMatches();\n\t\treturn query [Symbol.iterator]();\n\t}\n\n\tselectMatches() {\n\t\tlet query = _runtime.getRootNode(this.relativeToElement).querySelectorAll(this.css);\n\t\treturn query;\n\t}\n}\n\n//====================================================================\n// Lexer\n//====================================================================\n\n/** @type LexerObject */\nvar _lexer = (function () {\n\tvar OP_TABLE = {\n\t\t\"+\": \"PLUS\",\n\t\t\"-\": \"MINUS\",\n\t\t\"*\": \"MULTIPLY\",\n\t\t\"/\": \"DIVIDE\",\n\t\t\".\": \"PERIOD\",\n\t\t\"..\": \"ELLIPSIS\",\n\t\t\"\\\\\": \"BACKSLASH\",\n\t\t\":\": \"COLON\",\n\t\t\"%\": \"PERCENT\",\n\t\t\"|\": \"PIPE\",\n\t\t\"!\": \"EXCLAMATION\",\n\t\t\"?\": \"QUESTION\",\n\t\t\"#\": \"POUND\",\n\t\t\"&\": \"AMPERSAND\",\n\t\t$: \"DOLLAR\",\n\t\t\";\": \"SEMI\",\n\t\t\",\": \"COMMA\",\n\t\t\"(\": \"L_PAREN\",\n\t\t\")\": \"R_PAREN\",\n\t\t\"<\": \"L_ANG\",\n\t\t\">\": \"R_ANG\",\n\t\t\"<=\": \"LTE_ANG\",\n\t\t\">=\": \"GTE_ANG\",\n\t\t\"==\": \"EQ\",\n\t\t\"===\": \"EQQ\",\n\t\t\"!=\": \"NEQ\",\n\t\t\"!==\": \"NEQQ\",\n\t\t\"{\": \"L_BRACE\",\n\t\t\"}\": \"R_BRACE\",\n\t\t\"[\": \"L_BRACKET\",\n\t\t\"]\": \"R_BRACKET\",\n\t\t\"=\": \"EQUALS\",\n\t};\n\n\t/**\n\t * isValidCSSClassChar returns `true` if the provided character is valid in a CSS class.\n\t * @param {string} c\n\t * @returns boolean\n\t */\n\tfunction isValidCSSClassChar(c) {\n\t\treturn isAlpha(c) || isNumeric(c) || c === \"-\" || c === \"_\" || c === \":\";\n\t}\n\n\t/**\n\t * isValidCSSIDChar returns `true` if the provided character is valid in a CSS ID\n\t * @param {string} c\n\t * @returns boolean\n\t */\n\tfunction isValidCSSIDChar(c) {\n\t\treturn isAlpha(c) || isNumeric(c) || c === \"-\" || c === \"_\" || c === \":\";\n\t}\n\n\t/**\n\t * isWhitespace returns `true` if the provided character is whitespace.\n\t * @param {string} c\n\t * @returns boolean\n\t */\n\tfunction isWhitespace(c) {\n\t\treturn c === \" \" || c === \"\\t\" || isNewline(c);\n\t}\n\n\t/**\n\t * positionString returns a string representation of a Token's line and column details.\n\t * @param {Token} token\n\t * @returns string\n\t */\n\tfunction positionString(token) {\n\t\treturn \"[Line: \" + token.line + \", Column: \" + token.column + \"]\";\n\t}\n\n\t/**\n\t * isNewline returns `true` if the provided character is a carrage return or newline\n\t * @param {string} c\n\t * @returns boolean\n\t */\n\tfunction isNewline(c) {\n\t\treturn c === \"\\r\" || c === \"\\n\";\n\t}\n\n\t/**\n\t * isNumeric returns `true` if the provided character is a number (0-9)\n\t * @param {string} c\n\t * @returns boolean\n\t */\n\tfunction isNumeric(c) {\n\t\treturn c >= \"0\" && c <= \"9\";\n\t}\n\n\t/**\n\t * isAlpha returns `true` if the provided character is a letter in the alphabet\n\t * @param {string} c\n\t * @returns boolean\n\t */\n\tfunction isAlpha(c) {\n\t\treturn (c >= \"a\" && c <= \"z\") || (c >= \"A\" && c <= \"Z\");\n\t}\n\n\t/**\n\t * @param {string} c\n\t * @param {boolean} [dollarIsOp]\n\t * @returns boolean\n\t */\n\tfunction isIdentifierChar(c, dollarIsOp) {\n\t\treturn c === \"_\" || c === \"$\";\n\t}\n\n\t/**\n\t * @param {string} c\n\t * @returns boolean\n\t */\n\tfunction isReservedChar(c) {\n\t\treturn c === \"`\" || c === \"^\";\n\t}\n\n\t/**\n\t * @param {Token[]} tokens\n\t * @param {Token[]} consumed\n\t * @param {string} source\n\t * @returns {TokensObject}\n\t */\n\tfunction makeTokensObject(tokens, consumed, source) {\n\t\tconsumeWhitespace(); // consume initial whitespace\n\n\t\t/** @type Token | null */\n\t\tvar _lastConsumed = null;\n\n\t\tfunction consumeWhitespace() {\n\t\t\twhile (token(0, true).type === \"WHITESPACE\") {\n\t\t\t\tconsumed.push(tokens.shift());\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @param {TokensObject} tokens\n\t\t * @param {*} error\n\t\t */\n\t\tfunction raiseError(tokens, error) {\n\t\t\t_parser.raiseParseError(tokens, error);\n\t\t}\n\n\t\t/**\n\t\t * @param {string} value\n\t\t * @returns {Token}\n\t\t */\n\t\tfunction requireOpToken(value) {\n\t\t\tvar token = matchOpToken(value);\n\t\t\tif (token) {\n\t\t\t\treturn token;\n\t\t\t} else {\n\t\t\t\traiseError(this, \"Expected '\" + value + \"' but found '\" + currentToken().value + \"'\");\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @param {string} op1\n\t\t * @param {string} [op2]\n\t\t * @param {string} [op3]\n\t\t * @returns {Token | void}\n\t\t */\n\t\tfunction matchAnyOpToken(op1, op2, op3) {\n\t\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\t\tvar opToken = arguments[i];\n\t\t\t\tvar match = matchOpToken(opToken);\n\t\t\t\tif (match) {\n\t\t\t\t\treturn match;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @param {string} op1\n\t\t * @param {string} [op2]\n\t\t * @param {string} [op3]\n\t\t * @returns {Token | void}\n\t\t */\n\t\tfunction matchAnyToken(op1, op2, op3) {\n\t\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\t\tvar opToken = arguments[i];\n\t\t\t\tvar match = matchToken(opToken);\n\t\t\t\tif (match) {\n\t\t\t\t\treturn match;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @param {string} value\n\t\t * @returns {Token | void}\n\t\t */\n\t\tfunction matchOpToken(value) {\n\t\t\tif (currentToken() && currentToken().op && currentToken().value === value) {\n\t\t\t\treturn consumeToken();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @param {string} type1\n\t\t * @param {string} [type2]\n\t\t * @param {string} [type3]\n\t\t * @param {string} [type4]\n\t\t * @returns {Token}\n\t\t */\n\t\tfunction requireTokenType(type1, type2, type3, type4) {\n\t\t\tvar token = matchTokenType(type1, type2, type3, type4);\n\t\t\tif (token) {\n\t\t\t\treturn token;\n\t\t\t} else {\n\t\t\t\traiseError(this, \"Expected one of \" + JSON.stringify([type1, type2, type3]));\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @param {string} type1\n\t\t * @param {string} [type2]\n\t\t * @param {string} [type3]\n\t\t * @param {string} [type4]\n\t\t * @returns {Token | void}\n\t\t */\n\t\tfunction matchTokenType(type1, type2, type3, type4) {\n\t\t\tif (\n\t\t\t\tcurrentToken() &&\n\t\t\t\tcurrentToken().type &&\n\t\t\t\t[type1, type2, type3, type4].indexOf(currentToken().type) >= 0\n\t\t\t) {\n\t\t\t\treturn consumeToken();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @param {string} value\n\t\t * @param {string} [type]\n\t\t * @returns {Token}\n\t\t */\n\t\tfunction requireToken(value, type) {\n\t\t\tvar token = matchToken(value, type);\n\t\t\tif (token) {\n\t\t\t\treturn token;\n\t\t\t} else {\n\t\t\t\traiseError(this, \"Expected '\" + value + \"' but found '\" + currentToken().value + \"'\");\n\t\t\t}\n\t\t}\n\n\t\tfunction peekToken(value, peek, type) {\n\t\t\treturn tokens[peek] && tokens[peek].value === value && tokens[peek].type === type\n\t\t}\n\n\t\t/**\n\t\t * @param {string} value\n\t\t * @param {string} [type]\n\t\t * @returns {Token | void}\n\t\t */\n\t\tfunction matchToken(value, type) {\n\t\t\tif (follows.indexOf(value) !== -1) {\n\t\t\t\treturn; // disallowed token here\n\t\t\t}\n\t\t\tvar type = type || \"IDENTIFIER\";\n\t\t\tif (currentToken() && currentToken().value === value && currentToken().type === type) {\n\t\t\t\treturn consumeToken();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @returns {Token}\n\t\t */\n\t\tfunction consumeToken() {\n\t\t\tvar match = tokens.shift();\n\t\t\tconsumed.push(match);\n\t\t\t_lastConsumed = match;\n\t\t\tconsumeWhitespace(); // consume any whitespace\n\t\t\treturn match;\n\t\t}\n\n\t\t/**\n\t\t * @param {string} value\n\t\t * @param {string} [type]\n\t\t * @returns {Token[]}\n\t\t */\n\t\tfunction consumeUntil(value, type) {\n\t\t\t/** @type Token[] */\n\t\t\tvar tokenList = [];\n\t\t\tvar currentToken = token(0, true);\n\n\t\t\twhile (\n\t\t\t\t(type == null || currentToken.type !== type) &&\n\t\t\t\t(value == null || currentToken.value !== value) &&\n\t\t\t\tcurrentToken.type !== \"EOF\"\n\t\t\t) {\n\t\t\t\tvar match = tokens.shift();\n\t\t\t\tconsumed.push(match);\n\t\t\t\ttokenList.push(currentToken);\n\t\t\t\tcurrentToken = token(0, true);\n\t\t\t}\n\t\t\tconsumeWhitespace(); // consume any whitespace\n\t\t\treturn tokenList;\n\t\t}\n\n\t\t/**\n\t\t * @returns {string}\n\t\t */\n\t\tfunction lastWhitespace() {\n\t\t\tif (consumed[consumed.length - 1] && consumed[consumed.length - 1].type === \"WHITESPACE\") {\n\t\t\t\treturn consumed[consumed.length - 1].value;\n\t\t\t} else {\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t}\n\n\t\tfunction consumeUntilWhitespace() {\n\t\t\treturn consumeUntil(null, \"WHITESPACE\");\n\t\t}\n\n\t\t/**\n\t\t * @returns {boolean}\n\t\t */\n\t\tfunction hasMore() {\n\t\t\treturn tokens.length > 0;\n\t\t}\n\n\t\t/**\n\t\t * @param {number} n\n\t\t * @param {boolean} [dontIgnoreWhitespace]\n\t\t * @returns {Token}\n\t\t */\n\t\tfunction token(n, dontIgnoreWhitespace) {\n\t\t\tvar /**@type {Token}*/ token;\n\t\t\tvar i = 0;\n\t\t\tdo {\n\t\t\t\tif (!dontIgnoreWhitespace) {\n\t\t\t\t\twhile (tokens[i] && tokens[i].type === \"WHITESPACE\") {\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttoken = tokens[i];\n\t\t\t\tn--;\n\t\t\t\ti++;\n\t\t\t} while (n > -1);\n\t\t\tif (token) {\n\t\t\t\treturn token;\n\t\t\t} else {\n\t\t\t\treturn {\n\t\t\t\t\ttype: \"EOF\",\n\t\t\t\t\tvalue: \"<<<EOF>>>\",\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @returns {Token}\n\t\t */\n\t\tfunction currentToken() {\n\t\t\treturn token(0);\n\t\t}\n\n\t\t/**\n\t\t * @returns {Token | null}\n\t\t */\n\t\tfunction lastMatch() {\n\t\t\treturn _lastConsumed;\n\t\t}\n\n\t\t/**\n\t\t * @returns {string}\n\t\t */\n\t\tfunction sourceFor() {\n\t\t\treturn source.substring(this.startToken.start, this.endToken.end);\n\t\t}\n\n\t\t/**\n\t\t * @returns {string}\n\t\t */\n\t\tfunction lineFor() {\n\t\t\treturn source.split(\"\\n\")[this.startToken.line - 1];\n\t\t}\n\n\t\tvar follows = [];\n\n\t\tfunction pushFollow(str) {\n\t\t\tfollows.push(str);\n\t\t}\n\n\t\tfunction popFollow() {\n\t\t\tfollows.pop();\n\t\t}\n\n\t\tfunction clearFollows() {\n\t\t\tvar tmp = follows;\n\t\t\tfollows = [];\n\t\t\treturn tmp;\n\t\t}\n\n\t\tfunction restoreFollows(f) {\n\t\t\tfollows = f;\n\t\t}\n\n\t\t/** @type {TokensObject} */\n\t\treturn {\n\t\t\tpushFollow: pushFollow,\n\t\t\tpopFollow: popFollow,\n\t\t\tclearFollow: clearFollows,\n\t\t\trestoreFollow: restoreFollows,\n\t\t\tmatchAnyToken: matchAnyToken,\n\t\t\tmatchAnyOpToken: matchAnyOpToken,\n\t\t\tmatchOpToken: matchOpToken,\n\t\t\trequireOpToken: requireOpToken,\n\t\t\tmatchTokenType: matchTokenType,\n\t\t\trequireTokenType: requireTokenType,\n\t\t\tconsumeToken: consumeToken,\n\t\t\tpeekToken: peekToken,\n\t\t\tmatchToken: matchToken,\n\t\t\trequireToken: requireToken,\n\t\t\tlist: tokens,\n\t\t\tconsumed: consumed,\n\t\t\tsource: source,\n\t\t\thasMore: hasMore,\n\t\t\tcurrentToken: currentToken,\n\t\t\tlastMatch: lastMatch,\n\t\t\ttoken: token,\n\t\t\tconsumeUntil: consumeUntil,\n\t\t\tconsumeUntilWhitespace: consumeUntilWhitespace,\n\t\t\tlastWhitespace: lastWhitespace,\n\t\t\tsourceFor: sourceFor,\n\t\t\tlineFor: lineFor,\n\t\t};\n\t}\n\n\t/**\n\t * @param {Token[]} tokens\n\t * @returns {boolean}\n\t */\n\tfunction isValidSingleQuoteStringStart(tokens) {\n\t\tif (tokens.length > 0) {\n\t\t\tvar previousToken = tokens[tokens.length - 1];\n\t\t\tif (\n\t\t\t\tpreviousToken.type === \"IDENTIFIER\" ||\n\t\t\t\tpreviousToken.type === \"CLASS_REF\" ||\n\t\t\t\tpreviousToken.type === \"ID_REF\"\n\t\t\t) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (previousToken.op && (previousToken.value === \">\" || previousToken.value === \")\")) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {string} string\n\t * @param {boolean} [template]\n\t * @returns {TokensObject}\n\t */\n\tfunction tokenize(string, template) {\n\t\tvar tokens = /** @type {Token[]}*/ [];\n\t\tvar source = string;\n\t\tvar position = 0;\n\t\tvar column = 0;\n\t\tvar line = 1;\n\t\tvar lastToken = \"<START>\";\n\t\tvar templateBraceCount = 0;\n\n\t\tfunction inTemplate() {\n\t\t\treturn template && templateBraceCount === 0;\n\t\t}\n\n\t\twhile (position < source.length) {\n\t\t\tif (currentChar() === \"-\" && nextChar() === \"-\" && (isWhitespace(charAfterThat()) || charAfterThat() === \"\")) {\n\t\t\t\tconsumeComment();\n\t\t\t} else {\n\t\t\t\tif (isWhitespace(currentChar())) {\n\t\t\t\t\ttokens.push(consumeWhitespace());\n\t\t\t\t} else if (\n\t\t\t\t\t!possiblePrecedingSymbol() &&\n\t\t\t\t\tcurrentChar() === \".\" &&\n\t\t\t\t\t(isAlpha(nextChar()) || nextChar() === \"{\")\n\t\t\t\t) {\n\t\t\t\t\ttokens.push(consumeClassReference());\n\t\t\t\t} else if (\n\t\t\t\t\t!possiblePrecedingSymbol() &&\n\t\t\t\t\tcurrentChar() === \"#\" &&\n\t\t\t\t\t(isAlpha(nextChar()) || nextChar() === \"{\")\n\t\t\t\t) {\n\t\t\t\t\ttokens.push(consumeIdReference());\n\t\t\t\t} else if (currentChar() === \"[\" && nextChar() === \"@\") {\n\t\t\t\t\ttokens.push(consumeAttributeReference());\n\t\t\t\t} else if (currentChar() === \"@\") {\n\t\t\t\t\ttokens.push(consumeShortAttributeReference());\n\t\t\t\t} else if (currentChar() === \"*\" && isAlpha(nextChar())) {\n\t\t\t\t\ttokens.push(consumeStyleReference());\n\t\t\t\t} else if (isAlpha(currentChar()) || (!inTemplate() && isIdentifierChar(currentChar()))) {\n\t\t\t\t\ttokens.push(consumeIdentifier());\n\t\t\t\t} else if (isNumeric(currentChar())) {\n\t\t\t\t\ttokens.push(consumeNumber());\n\t\t\t\t} else if (!inTemplate() && (currentChar() === '\"' || currentChar() === \"`\")) {\n\t\t\t\t\ttokens.push(consumeString());\n\t\t\t\t} else if (!inTemplate() && currentChar() === \"'\") {\n\t\t\t\t\tif (isValidSingleQuoteStringStart(tokens)) {\n\t\t\t\t\t\ttokens.push(consumeString());\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttokens.push(consumeOp());\n\t\t\t\t\t}\n\t\t\t\t} else if (OP_TABLE[currentChar()]) {\n\t\t\t\t\tif (lastToken === \"$\" && currentChar() === \"{\") {\n\t\t\t\t\t\ttemplateBraceCount++;\n\t\t\t\t\t}\n\t\t\t\t\tif (currentChar() === \"}\") {\n\t\t\t\t\t\ttemplateBraceCount--;\n\t\t\t\t\t}\n\t\t\t\t\ttokens.push(consumeOp());\n\t\t\t\t} else if (inTemplate() || isReservedChar(currentChar())) {\n\t\t\t\t\ttokens.push(makeToken(\"RESERVED\", consumeChar()));\n\t\t\t\t} else {\n\t\t\t\t\tif (position < source.length) {\n\t\t\t\t\t\tthrow Error(\"Unknown token: \" + currentChar() + \" \");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn makeTokensObject(tokens, [], source);\n\n\t\t/**\n\t\t * @param {string} [type]\n\t\t * @param {string} [value]\n\t\t * @returns {Token}\n\t\t */\n\t\tfunction makeOpToken(type, value) {\n\t\t\tvar token = makeToken(type, value);\n\t\t\ttoken.op = true;\n\t\t\treturn token;\n\t\t}\n\n\t\t/**\n\t\t * @param {string} [type]\n\t\t * @param {string} [value]\n\t\t * @returns {Token}\n\t\t */\n\t\tfunction makeToken(type, value) {\n\t\t\treturn {\n\t\t\t\ttype: type,\n\t\t\t\tvalue: value,\n\t\t\t\tstart: position,\n\t\t\t\tend: position + 1,\n\t\t\t\tcolumn: column,\n\t\t\t\tline: line,\n\t\t\t};\n\t\t}\n\n\t\tfunction consumeComment() {\n\t\t\twhile (currentChar() && !isNewline(currentChar())) {\n\t\t\t\tconsumeChar();\n\t\t\t}\n\t\t\tconsumeChar();\n\t\t}\n\n\t\t/**\n\t\t * @returns Token\n\t\t */\n\t\tfunction consumeClassReference() {\n\t\t\tvar classRef = makeToken(\"CLASS_REF\");\n\t\t\tvar value = consumeChar();\n\t\t\tif (currentChar() === \"{\") {\n\t\t\t\tclassRef.template = true;\n\t\t\t\tvalue += consumeChar();\n\t\t\t\twhile (currentChar() && currentChar() !== \"}\") {\n\t\t\t\t\tvalue += consumeChar();\n\t\t\t\t}\n\t\t\t\tif (currentChar() !== \"}\") {\n\t\t\t\t\tthrow Error(\"Unterminated class reference\");\n\t\t\t\t} else {\n\t\t\t\t\tvalue += consumeChar(); // consume final curly\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile (isValidCSSClassChar(currentChar())) {\n\t\t\t\t\tvalue += consumeChar();\n\t\t\t\t}\n\t\t\t}\n\t\t\tclassRef.value = value;\n\t\t\tclassRef.end = position;\n\t\t\treturn classRef;\n\t\t}\n\n\t\t/**\n\t\t * @returns Token\n\t\t */\n\t\tfunction consumeAttributeReference() {\n\t\t\tvar attributeRef = makeToken(\"ATTRIBUTE_REF\");\n\t\t\tvar value = consumeChar();\n\t\t\twhile (position < source.length && currentChar() !== \"]\") {\n\t\t\t\tvalue += consumeChar();\n\t\t\t}\n\t\t\tif (currentChar() === \"]\") {\n\t\t\t\tvalue += consumeChar();\n\t\t\t}\n\t\t\tattributeRef.value = value;\n\t\t\tattributeRef.end = position;\n\t\t\treturn attributeRef;\n\t\t}\n\n\t\tfunction consumeShortAttributeReference() {\n\t\t\tvar attributeRef = makeToken(\"ATTRIBUTE_REF\");\n\t\t\tvar value = consumeChar();\n\t\t\twhile (isValidCSSIDChar(currentChar())) {\n\t\t\t\tvalue += consumeChar();\n\t\t\t}\n\t\t\tattributeRef.value = value;\n\t\t\tattributeRef.end = position;\n\t\t\treturn attributeRef;\n\t\t}\n\n\t\tfunction consumeStyleReference() {\n\t\t\tvar styleRef = makeToken(\"STYLE_REF\");\n\t\t\tvar value = consumeChar();\n\t\t\twhile (isAlpha(currentChar()) || currentChar() === \"-\") {\n\t\t\t\tvalue += consumeChar();\n\t\t\t}\n\t\t\tstyleRef.value = value;\n\t\t\tstyleRef.end = position;\n\t\t\treturn styleRef;\n\t\t}\n\n\t\t/**\n\t\t * @returns Token\n\t\t */\n\t\tfunction consumeIdReference() {\n\t\t\tvar idRef = makeToken(\"ID_REF\");\n\t\t\tvar value = consumeChar();\n\t\t\tif (currentChar() === \"{\") {\n\t\t\t\tidRef.template = true;\n\t\t\t\tvalue += consumeChar();\n\t\t\t\twhile (currentChar() && currentChar() !== \"}\") {\n\t\t\t\t\tvalue += consumeChar();\n\t\t\t\t}\n\t\t\t\tif (currentChar() !== \"}\") {\n\t\t\t\t\tthrow Error(\"Unterminated id reference\");\n\t\t\t\t} else {\n\t\t\t\t\tconsumeChar(); // consume final quote\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile (isValidCSSIDChar(currentChar())) {\n\t\t\t\t\tvalue += consumeChar();\n\t\t\t\t}\n\t\t\t}\n\t\t\tidRef.value = value;\n\t\t\tidRef.end = position;\n\t\t\treturn idRef;\n\t\t}\n\n\t\t/**\n\t\t * @returns Token\n\t\t */\n\t\tfunction consumeIdentifier() {\n\t\t\tvar identifier = makeToken(\"IDENTIFIER\");\n\t\t\tvar value = consumeChar();\n\t\t\twhile (isAlpha(currentChar()) ||\n\t\t\t       isNumeric(currentChar()) ||\n\t\t\t       isIdentifierChar(currentChar())) {\n\t\t\t\tvalue += consumeChar();\n\t\t\t}\n\t\t\tif (currentChar() === \"!\" && value === \"beep\") {\n\t\t\t\tvalue += consumeChar();\n\t\t\t}\n\t\t\tidentifier.value = value;\n\t\t\tidentifier.end = position;\n\t\t\treturn identifier;\n\t\t}\n\n\t\t/**\n\t\t * @returns Token\n\t\t */\n\t\tfunction consumeNumber() {\n\t\t\tvar number = makeToken(\"NUMBER\");\n\t\t\tvar value = consumeChar();\n\t\t\twhile (isNumeric(currentChar())) {\n\t\t\t\tvalue += consumeChar();\n\t\t\t}\n\t\t\tif (currentChar() === \".\" && isNumeric(nextChar())) {\n\t\t\t\tvalue += consumeChar();\n\t\t\t}\n\t\t\twhile (isNumeric(currentChar())) {\n\t\t\t\tvalue += consumeChar();\n\t\t\t}\n\t\t\tnumber.value = value;\n\t\t\tnumber.end = position;\n\t\t\treturn number;\n\t\t}\n\n\t\t/**\n\t\t * @returns Token\n\t\t */\n\t\tfunction consumeOp() {\n\t\t\tvar op = makeOpToken();\n\t\t\tvar value = consumeChar(); // consume leading char\n\t\t\twhile (currentChar() && OP_TABLE[value + currentChar()]) {\n\t\t\t\tvalue += consumeChar();\n\t\t\t}\n\t\t\top.type = OP_TABLE[value];\n\t\t\top.value = value;\n\t\t\top.end = position;\n\t\t\treturn op;\n\t\t}\n\n\t\t/**\n\t\t * @returns Token\n\t\t */\n\t\tfunction consumeString() {\n\t\t\tvar string = makeToken(\"STRING\");\n\t\t\tvar startChar = consumeChar(); // consume leading quote\n\t\t\tvar value = \"\";\n\t\t\twhile (currentChar() && currentChar() !== startChar) {\n\t\t\t\tif (currentChar() === \"\\\\\") {\n\t\t\t\t\tconsumeChar(); // consume escape char and get the next one\n\t\t\t\t\tlet nextChar = consumeChar();\n\t\t\t\t\tif (nextChar === \"b\") {\n\t\t\t\t\t\tvalue += \"\\b\";\n\t\t\t\t\t} else if (nextChar === \"f\") {\n\t\t\t\t\t\tvalue += \"\\f\";\n\t\t\t\t\t} else if (nextChar === \"n\") {\n\t\t\t\t\t\tvalue += \"\\n\";\n\t\t\t\t\t} else if (nextChar === \"r\") {\n\t\t\t\t\t\tvalue += \"\\r\";\n\t\t\t\t\t} else if (nextChar === \"t\") {\n\t\t\t\t\t\tvalue += \"\\t\";\n\t\t\t\t\t} else if (nextChar === \"v\") {\n\t\t\t\t\t\tvalue += \"\\v\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalue += nextChar;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tvalue += consumeChar();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (currentChar() !== startChar) {\n\t\t\t\tthrow Error(\"Unterminated string at \" + positionString(string));\n\t\t\t} else {\n\t\t\t\tconsumeChar(); // consume final quote\n\t\t\t}\n\t\t\tstring.value = value;\n\t\t\tstring.end = position;\n\t\t\tstring.template = startChar === \"`\";\n\t\t\treturn string;\n\t\t}\n\n\t\t/**\n\t\t * @returns string\n\t\t */\n\t\tfunction currentChar() {\n\t\t\treturn source.charAt(position);\n\t\t}\n\n\t\t/**\n\t\t * @returns string\n\t\t */\n\t\tfunction nextChar() {\n\t\t\treturn source.charAt(position + 1);\n\t\t}\n\n\t\tfunction charAfterThat() {\n\t\t\treturn source.charAt(position + 2);\n\t\t}\n\n\t\t/**\n\t\t * @returns string\n\t\t */\n\t\tfunction consumeChar() {\n\t\t\tlastToken = currentChar();\n\t\t\tposition++;\n\t\t\tcolumn++;\n\t\t\treturn lastToken;\n\t\t}\n\n\t\t/**\n\t\t * @returns boolean\n\t\t */\n\t\tfunction possiblePrecedingSymbol() {\n\t\t\treturn (\n\t\t\t\tisAlpha(lastToken) ||\n\t\t\t\tisNumeric(lastToken) ||\n\t\t\t\tlastToken === \")\" ||\n\t\t\t\tlastToken === \"\\\"\" ||\n\t\t\t\tlastToken === \"'\" ||\n\t\t\t\tlastToken === \"`\" ||\n\t\t\t\tlastToken === \"}\" ||\n\t\t\t\tlastToken === \"]\"\n\t\t\t);\n\t\t}\n\n\t\t/**\n\t\t * @returns Token\n\t\t */\n\t\tfunction consumeWhitespace() {\n\t\t\tvar whitespace = makeToken(\"WHITESPACE\");\n\t\t\tvar value = \"\";\n\t\t\twhile (currentChar() && isWhitespace(currentChar())) {\n\t\t\t\tif (isNewline(currentChar())) {\n\t\t\t\t\tcolumn = 0;\n\t\t\t\t\tline++;\n\t\t\t\t}\n\t\t\t\tvalue += consumeChar();\n\t\t\t}\n\t\t\twhitespace.value = value;\n\t\t\twhitespace.end = position;\n\t\t\treturn whitespace;\n\t\t}\n\t}\n\n\treturn {\n\t\ttokenize: tokenize,\n\t\tmakeTokensObject: makeTokensObject,\n\t};\n})();\n\n//====================================================================\n// Parser\n//====================================================================\n\n/** @type ParserObject */\nvar _parser = (function () {\n\t/** @type {Object<string,GrammarDefinition>} */\n\tvar GRAMMAR = {};\n\n\t/** @type {Object<string,GrammarDefinition>} */\n\tvar COMMANDS = {};\n\n\t/** @type {Object<string,GrammarDefinition>} */\n\tvar FEATURES = {};\n\n\tvar LEAF_EXPRESSIONS = [];\n\tvar INDIRECT_EXPRESSIONS = [];\n\n\t/**\n\t * @param {*} parseElement\n\t * @param {*} start\n\t * @param {TokensObject} tokens\n\t */\n\tfunction initElt(parseElement, start, tokens) {\n\t\tparseElement.startToken = start;\n\t\tparseElement.sourceFor = tokens.sourceFor;\n\t\tparseElement.lineFor = tokens.lineFor;\n\t\tparseElement.programSource = tokens.source;\n\t}\n\n\t/**\n\t * @param {string} type\n\t * @param {TokensObject} tokens\n\t * @param {GrammarElement?} root\n\t * @returns GrammarElement\n\t */\n\tfunction parseElement(type, tokens, root = undefined) {\n\t\tvar elementDefinition = GRAMMAR[type];\n\t\tif (elementDefinition) {\n\t\t\tvar start = tokens.currentToken();\n\t\t\tvar parseElement = elementDefinition(_parser, _runtime, tokens, root);\n\t\t\tif (parseElement) {\n\t\t\t\tinitElt(parseElement, start, tokens);\n\t\t\t\tparseElement.endToken = parseElement.endToken || tokens.lastMatch();\n\t\t\t\tvar root = parseElement.root;\n\t\t\t\twhile (root != null) {\n\t\t\t\t\tinitElt(root, start, tokens);\n\t\t\t\t\troot = root.root;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn parseElement;\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} type\n\t * @param {TokensObject} tokens\n\t * @param {string} [message]\n\t * @param {*} [root]\n\t * @returns {GrammarElement}\n\t */\n\tfunction requireElement(type, tokens, message, root) {\n\t\tvar result = parseElement(type, tokens, root);\n\t\tif (!result) raiseParseError(tokens, message || \"Expected \" + type);\n\t\t// @ts-ignore\n\t\treturn result;\n\t}\n\n\t/**\n\t * @param {string[]} types\n\t * @param {TokensObject} tokens\n\t * @returns {GrammarElement}\n\t */\n\tfunction parseAnyOf(types, tokens) {\n\t\tfor (var i = 0; i < types.length; i++) {\n\t\t\tvar type = types[i];\n\t\t\tvar expression = parseElement(type, tokens);\n\t\t\tif (expression) {\n\t\t\t\treturn expression;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} name\n\t * @param {GrammarDefinition} definition\n\t */\n\tfunction addGrammarElement(name, definition) {\n\t\tGRAMMAR[name] = definition;\n\t}\n\n\t/**\n\t * @param {string} keyword\n\t * @param {GrammarDefinition} definition\n\t */\n\tfunction addCommand(keyword, definition) {\n\t\tvar commandGrammarType = keyword + \"Command\";\n\t\tvar commandDefinitionWrapper = function (parser, runtime, tokens) {\n\t\t\tconst commandElement = definition(parser, runtime, tokens);\n\t\t\tif (commandElement) {\n\t\t\t\tcommandElement.type = commandGrammarType;\n\t\t\t\tcommandElement.execute = function (context) {\n\t\t\t\t\tcontext.meta.command = commandElement;\n\t\t\t\t\treturn runtime.unifiedExec(this, context);\n\t\t\t\t};\n\t\t\t\treturn commandElement;\n\t\t\t}\n\t\t};\n\t\tGRAMMAR[commandGrammarType] = commandDefinitionWrapper;\n\t\tCOMMANDS[keyword] = commandDefinitionWrapper;\n\t}\n\n\t/**\n\t * @param {string} keyword\n\t * @param {GrammarDefinition} definition\n\t */\n\tfunction addFeature(keyword, definition) {\n\t\tvar featureGrammarType = keyword + \"Feature\";\n\n\t\t/** @type {GrammarDefinition} */\n\t\tvar featureDefinitionWrapper = function (parser, runtime, tokens) {\n\t\t\tvar featureElement = definition(parser, runtime, tokens);\n\t\t\tif (featureElement) {\n\t\t\t\tfeatureElement.isFeature = true;\n\t\t\t\tfeatureElement.keyword = keyword;\n\t\t\t\tfeatureElement.type = featureGrammarType;\n\t\t\t\treturn featureElement;\n\t\t\t}\n\t\t};\n\t\tGRAMMAR[featureGrammarType] = featureDefinitionWrapper;\n\t\tFEATURES[keyword] = featureDefinitionWrapper;\n\t}\n\n\t/**\n\t * @param {string} name\n\t * @param {GrammarDefinition} definition\n\t */\n\tfunction addLeafExpression(name, definition) {\n\t\tLEAF_EXPRESSIONS.push(name);\n\t\taddGrammarElement(name, definition);\n\t}\n\n\t/**\n\t * @param {string} name\n\t * @param {GrammarDefinition} definition\n\t */\n\tfunction addIndirectExpression(name, definition) {\n\t\tINDIRECT_EXPRESSIONS.push(name);\n\t\taddGrammarElement(name, definition);\n\t}\n\n\t/* ============================================================================================ */\n\t/* Core hyperscript Grammar Elements                                                            */\n\t/* ============================================================================================ */\n\taddGrammarElement(\"feature\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchOpToken(\"(\")) {\n\t\t\tvar featureElement = parser.requireElement(\"feature\", tokens);\n\t\t\ttokens.requireOpToken(\")\");\n\t\t\treturn featureElement;\n\t\t}\n\n\t\tvar featureDefinition = FEATURES[tokens.currentToken().value];\n\t\tif (featureDefinition) {\n\t\t\treturn featureDefinition(parser, runtime, tokens);\n\t\t}\n\t});\n\n\taddGrammarElement(\"command\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchOpToken(\"(\")) {\n\t\t\tconst commandElement = parser.requireElement(\"command\", tokens);\n\t\t\ttokens.requireOpToken(\")\");\n\t\t\treturn commandElement;\n\t\t}\n\n\t\tvar commandDefinition = COMMANDS[tokens.currentToken().value];\n\t\tlet commandElement;\n\t\tif (commandDefinition) {\n\t\t\tcommandElement = commandDefinition(parser, runtime, tokens);\n\t\t} else if (tokens.currentToken().type === \"IDENTIFIER\") {\n\t\t\tcommandElement = parser.parseElement(\"pseudoCommand\", tokens);\n\t\t}\n\t\tif (commandElement) {\n\t\t\treturn parser.parseElement(\"indirectStatement\", tokens, commandElement);\n\t\t}\n\n\t\treturn commandElement;\n\t});\n\n\taddGrammarElement(\"commandList\", function (parser, runtime, tokens) {\n\t\tvar cmd = parser.parseElement(\"command\", tokens);\n\t\tif (cmd) {\n\t\t\ttokens.matchToken(\"then\");\n\t\t\tconst next = parser.parseElement(\"commandList\", tokens);\n\t\t\tif (next) cmd.next = next;\n\t\t\treturn cmd;\n\t\t}\n\t});\n\n\taddGrammarElement(\"leaf\", function (parser, runtime, tokens) {\n\t\tvar result = parseAnyOf(LEAF_EXPRESSIONS, tokens);\n\t\t// symbol is last so it doesn't consume any constants\n\t\tif (result == null) {\n\t\t\treturn parseElement(\"symbol\", tokens);\n\t\t}\n\n\t\treturn result;\n\t});\n\n\taddGrammarElement(\"indirectExpression\", function (parser, runtime, tokens, root) {\n\t\tfor (var i = 0; i < INDIRECT_EXPRESSIONS.length; i++) {\n\t\t\tvar indirect = INDIRECT_EXPRESSIONS[i];\n\t\t\troot.endToken = tokens.lastMatch();\n\t\t\tvar result = parser.parseElement(indirect, tokens, root);\n\t\t\tif (result) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\treturn root;\n\t});\n\n\taddGrammarElement(\"indirectStatement\", function (parser, runtime, tokens, root) {\n\t\tif (tokens.matchToken(\"unless\")) {\n\t\t\troot.endToken = tokens.lastMatch();\n\t\t\tvar conditional = parser.requireElement(\"expression\", tokens);\n\t\t\tvar unless = {\n\t\t\t\ttype: \"unlessStatementModifier\",\n\t\t\t\targs: [conditional],\n\t\t\t\top: function (context, conditional) {\n\t\t\t\t\tif (conditional) {\n\t\t\t\t\t\treturn this.next;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn root;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\texecute: function (context) {\n\t\t\t\t\treturn runtime.unifiedExec(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t\troot.parent = unless;\n\t\t\treturn unless;\n\t\t}\n\t\treturn root;\n\t});\n\n\taddGrammarElement(\"primaryExpression\", function (parser, runtime, tokens) {\n\t\tvar leaf = parser.parseElement(\"leaf\", tokens);\n\t\tif (leaf) {\n\t\t\treturn parser.parseElement(\"indirectExpression\", tokens, leaf);\n\t\t}\n\t\tparser.raiseParseError(tokens, \"Unexpected value: \" + tokens.currentToken().value);\n\t});\n\n\t/* ============================================================================================ */\n\t/* END Core hyperscript Grammar Elements                                                        */\n\n\t/* ============================================================================================ */\n\n\t/**\n\t *\n\t * @param {TokensObject} tokens\n\t * @returns string\n\t */\n\tfunction createParserContext(tokens) {\n\t\tvar currentToken = tokens.currentToken();\n\t\tvar source = tokens.source;\n\t\tvar lines = source.split(\"\\n\");\n\t\tvar line = currentToken && currentToken.line ? currentToken.line - 1 : lines.length - 1;\n\t\tvar contextLine = lines[line];\n\t\tvar offset = currentToken && currentToken.line ? currentToken.column : contextLine.length - 1;\n\t\treturn contextLine + \"\\n\" + \" \".repeat(offset) + \"^^\\n\\n\";\n\t}\n\n\t/**\n\t * @param {TokensObject} tokens\n\t * @param {string} [message]\n\t */\n\tfunction raiseParseError(tokens, message) {\n\t\tmessage =\n\t\t\t(message || \"Unexpected Token : \" + tokens.currentToken().value) + \"\\n\\n\" + createParserContext(tokens);\n\t\tvar error = new Error(message);\n\t\terror[\"tokens\"] = tokens;\n\t\tthrow error;\n\t}\n\n\t/**\n\t * @param {TokensObject} tokens\n\t * @returns {GrammarElement}\n\t */\n\tfunction parseHyperScript(tokens) {\n\t\tvar result = parseElement(\"hyperscript\", tokens);\n\t\tif (tokens.hasMore()) raiseParseError(tokens);\n\t\tif (result) return result;\n\t}\n\n\t/**\n\t * @param {GrammarElement} elt\n\t * @param {GrammarElement} parent\n\t */\n\tfunction setParent(elt, parent) {\n\t\tif (typeof elt === 'object') {\n\t\t\telt.parent = parent;\n\t\t\tif (typeof parent === 'object') {\n\t\t\t\tparent.children = (parent.children || new Set());\n\t\t\t\tparent.children.add(elt)\n\t\t\t}\n\t\t\tsetParent(elt.next, parent);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Token} token\n\t * @returns {GrammarDefinition}\n\t */\n\tfunction commandStart(token) {\n\t\treturn COMMANDS[token.value];\n\t}\n\n\t/**\n\t * @param {Token} token\n\t * @returns {GrammarDefinition}\n\t */\n\tfunction featureStart(token) {\n\t\treturn FEATURES[token.value];\n\t}\n\n\t/**\n\t * @param {Token} token\n\t * @returns {boolean}\n\t */\n\tfunction commandBoundary(token) {\n\t\tif (\n\t\t\ttoken.value == \"end\" ||\n\t\t\ttoken.value == \"then\" ||\n\t\t\ttoken.value == \"else\" ||\n\t\t\ttoken.value == \"otherwise\" ||\n\t\t\ttoken.value == \")\" ||\n\t\t\tcommandStart(token) ||\n\t\t\tfeatureStart(token) ||\n\t\t\ttoken.type == \"EOF\"\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {TokensObject} tokens\n\t * @returns {(string | GrammarElement)[]}\n\t */\n\tfunction parseStringTemplate(tokens) {\n\t\t/** @type {(string | GrammarElement)[]} */\n\t\tvar returnArr = [\"\"];\n\t\tdo {\n\t\t\treturnArr.push(tokens.lastWhitespace());\n\t\t\tif (tokens.currentToken().value === \"$\") {\n\t\t\t\ttokens.consumeToken();\n\t\t\t\tvar startingBrace = tokens.matchOpToken(\"{\");\n\t\t\t\treturnArr.push(requireElement(\"expression\", tokens));\n\t\t\t\tif (startingBrace) {\n\t\t\t\t\ttokens.requireOpToken(\"}\");\n\t\t\t\t}\n\t\t\t\treturnArr.push(\"\");\n\t\t\t} else if (tokens.currentToken().value === \"\\\\\") {\n\t\t\t\ttokens.consumeToken(); // skip next\n\t\t\t\ttokens.consumeToken();\n\t\t\t} else {\n\t\t\t\tvar token = tokens.consumeToken();\n\t\t\t\treturnArr[returnArr.length - 1] += token ? token.value : \"\";\n\t\t\t}\n\t\t} while (tokens.hasMore());\n\t\treturnArr.push(tokens.lastWhitespace());\n\t\treturn returnArr;\n\t}\n\n\t/**\n\t * @param {GrammarElement} commandList\n\t */\n\tfunction ensureTerminated(commandList) {\n\t\tvar implicitReturn = {\n\t\t\ttype: \"implicitReturn\",\n\t\t\top: function (context) {\n\t\t\t\tcontext.meta.returned = true;\n\t\t\t\tif (context.meta.resolve) {\n\t\t\t\t\tcontext.meta.resolve();\n\t\t\t\t}\n\t\t\t\treturn _runtime.HALT;\n\t\t\t},\n\t\t\texecute: function (ctx) {\n\t\t\t\t// do nothing\n\t\t\t},\n\t\t};\n\n\t\tvar end = commandList;\n\t\twhile (end.next) {\n\t\t\tend = end.next;\n\t\t}\n\t\tend.next = implicitReturn;\n\t}\n\n\n\t// parser API\n\treturn {\n\t\tsetParent,\n\t\trequireElement,\n\t\tparseElement,\n\t\tfeatureStart,\n\t\tcommandStart,\n\t\tcommandBoundary,\n\t\tparseAnyOf,\n\t\tparseHyperScript,\n\t\traiseParseError,\n\t\taddGrammarElement,\n\t\taddCommand,\n\t\taddFeature,\n\t\taddLeafExpression,\n\t\taddIndirectExpression,\n\t\tparseStringTemplate,\n\t\tensureTerminated,\n\t};\n})();\n\n//====================================================================\n// Runtime\n//====================================================================\n\nvar CONVERSIONS = {\n\tdynamicResolvers: /** @type DynamicConversionFunction[] */ [\n\t\tfunction(str, value){\n\t\t\tif (str === \"Fixed\") {\n\t\t\t\treturn Number(value).toFixed();\n\t\t\t} else if (str.indexOf(\"Fixed:\") === 0) {\n\t\t\t\tlet num = str.split(\":\")[1];\n\t\t\t\treturn Number(value).toFixed(parseInt(num));\n\t\t\t}\n\t\t}\n\t],\n\tString: function (val) {\n\t\tif (val.toString) {\n\t\t\treturn val.toString();\n\t\t} else {\n\t\t\treturn \"\" + val;\n\t\t}\n\t},\n\tInt: function (val) {\n\t\treturn parseInt(val);\n\t},\n\tFloat: function (val) {\n\t\treturn parseFloat(val);\n\t},\n\tNumber: function (val) {\n\t\treturn Number(val);\n\t},\n\tDate: function (val) {\n\t\treturn new Date(val);\n\t},\n\tArray: function (val) {\n\t\treturn Array.from(val);\n\t},\n\tJSON: function (val) {\n\t\treturn JSON.stringify(val);\n\t},\n\tObject: function (val) {\n\t\tif (val instanceof String) {\n\t\t\tval = val.toString();\n\t\t}\n\t\tif (typeof val === \"string\") {\n\t\t\treturn JSON.parse(val);\n\t\t} else {\n\t\t\treturn mergeObjects({}, val);\n\t\t}\n\t},\n};\n\n/********************************************\n * RUNTIME OBJECT\n ********************************************/\n\n/** @type {RuntimeObject} */\nvar _runtime = (function () {\n\t/**\n\t * @param {HTMLElement} elt\n\t * @param {string} selector\n\t * @returns boolean\n\t */\n\tfunction matchesSelector(elt, selector) {\n\t\t// noinspection JSUnresolvedVariable\n\t\tvar matchesFunction =\n\t\t\t// @ts-ignore\n\t\t\telt.matches || elt.matchesSelector || elt.msMatchesSelector || elt.mozMatchesSelector || elt.webkitMatchesSelector || elt.oMatchesSelector;\n\t\treturn matchesFunction && matchesFunction.call(elt, selector);\n\t}\n\n\t/**\n\t * @param {string} eventName\n\t * @param {Object} [detail]\n\t * @returns {Event}\n\t */\n\tfunction makeEvent(eventName, detail) {\n\t\tvar evt;\n\t\tif (globalScope.Event && typeof globalScope.Event === \"function\") {\n\t\t\tevt = new Event(eventName, {\n\t\t\t\tbubbles: true,\n\t\t\t\tcancelable: true,\n\t\t\t});\n\t\t\tevt['detail'] = detail;\n\t\t} else {\n\t\t\tevt = document.createEvent(\"CustomEvent\");\n\t\t\tevt.initCustomEvent(eventName, true, true, detail);\n\t\t}\n\t\treturn evt;\n\t}\n\n\t/**\n\t * @param {Element} elt\n\t * @param {string} eventName\n\t * @param {Object} [detail]\n\t * @param {Element} sender\n\t * @returns {boolean}\n\t */\n\tfunction triggerEvent(elt, eventName, detail, sender) {\n\t\tdetail = detail || {};\n\t\tdetail[\"sender\"] = sender;\n\t\tvar event = makeEvent(eventName, detail);\n\t\tvar eventResult = elt.dispatchEvent(event);\n\t\treturn eventResult;\n\t}\n\n\t/**\n\t * isArrayLike returns `true` if the provided value is an array or\n\t * a NodeList (which is close enough to being an array for our purposes).\n\t *\n\t * @param {any} value\n\t * @returns {value is Array | NodeList}\n\t */\n\tfunction isArrayLike(value) {\n\t\treturn Array.isArray(value) ||\n\t\t\t(typeof NodeList !== 'undefined' && (value instanceof NodeList || value instanceof HTMLCollection));\n\t}\n\n\t/**\n\t * isIterable returns `true` if the provided value supports the\n\t * iterator protocol.\n\t *\n\t * @param {any} value\n\t * @returns {value is Iterable}\n\t */\n\tfunction isIterable(value) {\n\t\treturn typeof value === 'object'\n\t\t\t&& Symbol.iterator in value\n\t\t\t&& typeof value[Symbol.iterator] === 'function';\n\t}\n\n\t/**\n\t * shouldAutoIterate returns `true` if the provided value\n\t * should be implicitly iterated over when accessing properties,\n\t * and as the target of some commands.\n\t *\n\t * Currently, this is when the value is an {ElementCollection}\n\t * or {isArrayLike} returns true.\n\t *\n\t * @param {any} value\n\t * @returns {value is any[] | NodeList | ElementCollection}\n\t */\n\tfunction shouldAutoIterate(value) {\n\t\treturn  value instanceof ElementCollection ||\n\t\t\t   isArrayLike(value);\n\t}\n\n\t/**\n\t * forEach executes the provided `func` on every item in the `value` array.\n\t * if `value` is a single item (and not an array) then `func` is simply called\n\t * once.  If `value` is null, then no further actions are taken.\n\t *\n\t * @template T\n\t * @param {T | Iterable<T>} value\n\t * @param {(item: T) => void} func\n\t */\n\tfunction forEach(value, func) {\n\t\tif (value == null) {\n\t\t\t// do nothing\n\t\t} else if (isIterable(value)) {\n\t\t\tfor (const nth of value) {\n\t\t\t\tfunc(nth);\n\t\t\t}\n\t\t} else if (isArrayLike(value)) {\n\t\t\tfor (var i = 0; i < value.length; i++) {\n\t\t\t\tfunc(value[i]);\n\t\t\t}\n\t\t} else {\n\t\t\tfunc(value);\n\t\t}\n\t}\n\n\t/**\n\t * implicitLoop executes the provided `func` on:\n\t * - every item of {value}, if {value} should be auto-iterated\n\t *   (see {shouldAutoIterate})\n\t * - {value} otherwise\n\t *\n\t * @template T\n\t * @param {NodeList | T | T[]} value\n\t * @param {(item:Node | T) => void} func\n\t */\n\tfunction implicitLoop(value, func) {\n\t\tif (shouldAutoIterate(value)) {\n\t\t\tfor (const x of value) func(x);\n\t\t} else {\n\t\t\tfunc(value);\n\t\t}\n\t}\n\n\tfunction wrapArrays(args) {\n\t\tvar arr = [];\n\t\tfor (var i = 0; i < args.length; i++) {\n\t\t\tvar arg = args[i];\n\t\t\tif (Array.isArray(arg)) {\n\t\t\t\tarr.push(Promise.all(arg));\n\t\t\t} else {\n\t\t\t\tarr.push(arg);\n\t\t\t}\n\t\t}\n\t\treturn arr;\n\t}\n\n\tfunction unwrapAsyncs(values) {\n\t\tfor (var i = 0; i < values.length; i++) {\n\t\t\tvar value = values[i];\n\t\t\tif (value.asyncWrapper) {\n\t\t\t\tvalues[i] = value.value;\n\t\t\t}\n\t\t\tif (Array.isArray(value)) {\n\t\t\t\tfor (var j = 0; j < value.length; j++) {\n\t\t\t\t\tvar valueElement = value[j];\n\t\t\t\t\tif (valueElement.asyncWrapper) {\n\t\t\t\t\t\tvalue[j] = valueElement.value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvar HALT = {};\n\n\t/**\n\t * @param {GrammarElement} command\n\t * @param {Context} ctx\n\t */\n\tfunction unifiedExec(command, ctx) {\n\t\twhile (true) {\n\t\t\ttry {\n\t\t\t\tvar next = unifiedEval(command, ctx);\n\t\t\t} catch (e) {\n\t\t\t\tif (ctx.meta.handlingFinally) {\n\t\t\t\t\tconsole.error(\" Exception in finally block: \", e);\n\t\t\t\t\tnext = HALT;\n\t\t\t\t} else {\n\t\t\t\t\t_runtime.registerHyperTrace(ctx, e);\n\t\t\t\t\tif (ctx.meta.errorHandler && !ctx.meta.handlingError) {\n\t\t\t\t\t\tctx.meta.handlingError = true;\n\t\t\t\t\t\tctx[ctx.meta.errorSymbol] = e;\n\t\t\t\t\t\tcommand = ctx.meta.errorHandler;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else  {\n\t\t\t\t\t\tctx.meta.currentException = e;\n\t\t\t\t\t\tnext = HALT;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (next == null) {\n\t\t\t\tconsole.error(command, \" did not return a next element to execute! context: \", ctx);\n\t\t\t\treturn;\n\t\t\t} else if (next.then) {\n\t\t\t\tnext.then(function (resolvedNext) {\n\t\t\t\t\tunifiedExec(resolvedNext, ctx);\n\t\t\t\t}).catch(function (reason) {\n\t\t\t\t\tunifiedExec({ // Anonymous command to simply throw the exception\n\t\t\t\t\t\top: function(){\n\t\t\t\t\t\t\tthrow reason;\n\t\t\t\t\t\t}\n\t\t\t\t\t}, ctx);\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t} else if (next === HALT) {\n\t\t\t\tif (ctx.meta.finallyHandler && !ctx.meta.handlingFinally) {\n\t\t\t\t\tctx.meta.handlingFinally = true;\n\t\t\t\t\tcommand = ctx.meta.finallyHandler;\n\t\t\t\t} else {\n\t\t\t\t\tif (ctx.meta.onHalt) {\n\t\t\t\t\t\tctx.meta.onHalt();\n\t\t\t\t\t}\n\t\t\t\t\tif (ctx.meta.currentException) {\n\t\t\t\t\t\tif (ctx.meta.reject) {\n\t\t\t\t\t\t\tctx.meta.reject(ctx.meta.currentException);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow ctx.meta.currentException;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcommand = next; // move to the next command\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t* @param {*} parseElement\n\t* @param {Context} ctx\n\t* @returns {*}\n\t*/\n\tfunction unifiedEval(parseElement, ctx) {\n\t\t/** @type any[] */\n\t\tvar args = [ctx];\n\t\tvar async = false;\n\t\tvar wrappedAsyncs = false;\n\n\t\tif (parseElement.args) {\n\t\t\tfor (var i = 0; i < parseElement.args.length; i++) {\n\t\t\t\tvar argument = parseElement.args[i];\n\t\t\t\tif (argument == null) {\n\t\t\t\t\targs.push(null);\n\t\t\t\t} else if (Array.isArray(argument)) {\n\t\t\t\t\tvar arr = [];\n\t\t\t\t\tfor (var j = 0; j < argument.length; j++) {\n\t\t\t\t\t\tvar element = argument[j];\n\t\t\t\t\t\tvar value = element ? element.evaluate(ctx) : null; // OK\n\t\t\t\t\t\tif (value) {\n\t\t\t\t\t\t\tif (value.then) {\n\t\t\t\t\t\t\t\tasync = true;\n\t\t\t\t\t\t\t} else if (value.asyncWrapper) {\n\t\t\t\t\t\t\t\twrappedAsyncs = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tarr.push(value);\n\t\t\t\t\t}\n\t\t\t\t\targs.push(arr);\n\t\t\t\t} else if (argument.evaluate) {\n\t\t\t\t\tvar value = argument.evaluate(ctx); // OK\n\t\t\t\t\tif (value) {\n\t\t\t\t\t\tif (value.then) {\n\t\t\t\t\t\t\tasync = true;\n\t\t\t\t\t\t} else if (value.asyncWrapper) {\n\t\t\t\t\t\t\twrappedAsyncs = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\targs.push(value);\n\t\t\t\t} else {\n\t\t\t\t\targs.push(argument);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (async) {\n\t\t\treturn new Promise(function (resolve, reject) {\n\t\t\t\targs = wrapArrays(args);\n\t\t\t\tPromise.all(args)\n\t\t\t\t\t.then(function (values) {\n\t\t\t\t\t\tif (wrappedAsyncs) {\n\t\t\t\t\t\t\tunwrapAsyncs(values);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tvar apply = parseElement.op.apply(parseElement, values);\n\t\t\t\t\t\t\tresolve(apply);\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\treject(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t\t.catch(function (reason) {\n\t\t\t\t\t\treject(reason);\n\t\t\t\t\t});\n\t\t\t});\n\t\t} else {\n\t\t\tif (wrappedAsyncs) {\n\t\t\t\tunwrapAsyncs(args);\n\t\t\t}\n\t\t\treturn parseElement.op.apply(parseElement, args);\n\t\t}\n\t}\n\n\tlet _scriptAttrs = null;\n\n\t/**\n\t* getAttributes returns the attribute name(s) to use when\n\t* locating hyperscript scripts in a DOM element.  If no value\n\t* has been configured, it defaults to _hyperscript.config.attributes\n\t* @returns string[]\n\t*/\n\tfunction getScriptAttributes() {\n\t\tif (_scriptAttrs == null) {\n\t\t\t_scriptAttrs = _hyperscript.config.attributes.replace(/ /g, \"\").split(\",\");\n\t\t}\n\t\treturn _scriptAttrs;\n\t}\n\n\t/**\n\t* @param {Element} elt\n\t* @returns {string | null}\n\t*/\n\tfunction getScript(elt) {\n\t\tfor (var i = 0; i < getScriptAttributes().length; i++) {\n\t\t\tvar scriptAttribute = getScriptAttributes()[i];\n\t\t\tif (elt.hasAttribute && elt.hasAttribute(scriptAttribute)) {\n\t\t\t\treturn elt.getAttribute(scriptAttribute);\n\t\t\t}\n\t\t}\n\t\tif (elt instanceof HTMLScriptElement && elt.type === \"text/hyperscript\") {\n\t\t\treturn elt.innerText;\n\t\t}\n\t\treturn null;\n\t}\n\n\tvar hyperscriptFeaturesMap = new WeakMap\n\n\t/**\n\t* @param {*} elt\n\t* @returns {Object}\n\t*/\n\tfunction getHyperscriptFeatures(elt) {\n\t\tvar hyperscriptFeatures = hyperscriptFeaturesMap.get(elt);\n\t\tif (typeof hyperscriptFeatures === 'undefined') {\n\t\t\thyperscriptFeaturesMap.set(elt, hyperscriptFeatures = {});\n\t\t}\n\t\treturn hyperscriptFeatures;\n\t}\n\n\t/**\n\t* @param {Object} owner\n\t* @param {Context} ctx\n\t*/\n\tfunction addFeatures(owner, ctx) {\n\t\tif (owner) {\n\t\t\tmergeObjects(ctx, getHyperscriptFeatures(owner));\n\t\t\taddFeatures(owner.parentElement, ctx);\n\t\t}\n\t}\n\n\t/**\n\t* @param {*} owner\n\t* @param {*} feature\n\t* @param {*} hyperscriptTarget\n\t* @param {*} event\n\t* @returns {Context}\n\t*/\n\tfunction makeContext(owner, feature, hyperscriptTarget, event) {\n\t\t/** @type {Context} */\n\t\tvar ctx = {\n\t\t\tmeta: {\n\t\t\t\tparser: _parser,\n\t\t\t\tlexer: _lexer,\n\t\t\t\truntime: _runtime,\n\t\t\t\towner: owner,\n\t\t\t\tfeature: feature,\n\t\t\t\titerators: {},\n\t\t\t},\n\t\t\tme: hyperscriptTarget,\n\t\t\tevent: event,\n\t\t\ttarget: event ? event.target : null,\n\t\t\tdetail: event ? event.detail : null,\n\t\t\tsender: event ? event.detail ? event.detail.sender : null : null,\n\t\t\tbody: \"document\" in globalScope ? document.body : null,\n\t\t};\n\t\tctx.meta.ctx = ctx;\n\t\taddFeatures(owner, ctx);\n\t\treturn ctx;\n\t}\n\n\t/**\n\t* @returns string\n\t*/\n\tfunction getScriptSelector() {\n\t\treturn getScriptAttributes()\n\t\t\t.map(function (attribute) {\n\t\t\t\treturn \"[\" + attribute + \"]\";\n\t\t\t})\n\t\t\t.join(\", \");\n\t}\n\n\t/**\n\t* @param {any} value\n\t* @param {string} type\n\t* @returns {any}\n\t*/\n\tfunction convertValue(value, type) {\n\t\tvar dynamicResolvers = CONVERSIONS.dynamicResolvers;\n\t\tfor (var i = 0; i < dynamicResolvers.length; i++) {\n\t\t\tvar dynamicResolver = dynamicResolvers[i];\n\t\t\tvar converted = dynamicResolver(type, value);\n\t\t\tif (converted !== undefined) {\n\t\t\t\treturn converted;\n\t\t\t}\n\t\t}\n\n\t\tif (value == null) {\n\t\t\treturn null;\n\t\t}\n\t\tvar converter = CONVERSIONS[type];\n\t\tif (converter) {\n\t\t\treturn converter(value);\n\t\t}\n\n\t\tthrow \"Unknown conversion : \" + type;\n\t}\n\n\t// TODO: There do not seem to be any references to this function.\n\t// Is it still in use, or can it be removed?\n\tfunction isType(o, type) {\n\t\treturn Object.prototype.toString.call(o) === \"[object \" + type + \"]\";\n\t}\n\n\t/**\n\t* @param {string} src\n\t* @returns {GrammarElement}\n\t*/\n\tfunction parse(src) {\n\t\tvar tokens = _lexer.tokenize(src);\n\t\tif (_parser.commandStart(tokens.currentToken())) {\n\t\t\tvar commandList = _parser.requireElement(\"commandList\", tokens);\n\t\t\tif (tokens.hasMore()) _parser.raiseParseError(tokens);\n\t\t\t_parser.ensureTerminated(commandList);\n\t\t\treturn commandList;\n\t\t} else if (_parser.featureStart(tokens.currentToken())) {\n\t\t\tvar hyperscript = _parser.requireElement(\"hyperscript\", tokens);\n\t\t\tif (tokens.hasMore()) _parser.raiseParseError(tokens);\n\t\t\treturn hyperscript;\n\t\t} else {\n\t\t\tvar expression = _parser.requireElement(\"expression\", tokens);\n\t\t\tif (tokens.hasMore()) _parser.raiseParseError(tokens);\n\t\t\treturn expression;\n\t\t}\n\t}\n\n\t/**\n\t *\n\t * @param {GrammarElement} elt\n\t * @param {Context} ctx\n\t * @returns {any}\n\t */\n\tfunction evaluateNoPromise(elt, ctx) {\n\t\tlet result = elt.evaluate(ctx);\n\t\tif (result.next) {\n\t\t\tthrow new Error(elt.sourceFor() + \" returned a Promise in a context that they are not allowed.\");\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t* @param {string} src\n\t* @param {Context} [ctx]\n\t* @param {Object} [args]\n\t* @returns {any}\n\t*/\n\tfunction evaluate(src, ctx, args) {\n\t\tclass HyperscriptModule extends EventTarget {\n\t\t\tconstructor(mod) {\n\t\t\t\tsuper();\n\t\t\t\tthis.module = mod;\n\t\t\t}\n\t\t\ttoString() {\n\t\t\t\treturn this.module.id;\n\t\t\t}\n\t\t}\n\n\t\tvar body = 'document' in globalScope\n\t\t\t? globalScope.document.body\n\t\t\t: new HyperscriptModule(args && args.module);\n\t\tctx = mergeObjects(makeContext(body, null, body, null), ctx || {});\n\t\tvar element = parse(src);\n\t\tif (element.execute) {\n\t\t\telement.execute(ctx);\n\t\t\treturn ctx.result;\n\t\t} else if (element.apply) {\n\t\t\telement.apply(body, body, args);\n\t\t\treturn getHyperscriptFeatures(body);\n\t\t} else {\n\t\t\treturn element.evaluate(ctx);\n\t\t}\n\n\t\tfunction makeModule() {\n\t\t\treturn {}\n\t\t}\n\t}\n\n\t/**\n\t* @param {HTMLElement} elt\n\t*/\n\tfunction processNode(elt) {\n\t\tvar selector = _runtime.getScriptSelector();\n\t\tif (matchesSelector(elt, selector)) {\n\t\t\tinitElement(elt, elt);\n\t\t}\n\t\tif (elt instanceof HTMLScriptElement && elt.type === \"text/hyperscript\") {\n\t\t\tinitElement(elt, document.body);\n\t\t}\n\t\tif (elt.querySelectorAll) {\n\t\t\tforEach(elt.querySelectorAll(selector + \", [type='text/hyperscript']\"), function (elt) {\n\t\t\t\tinitElement(elt, elt instanceof HTMLScriptElement && elt.type === \"text/hyperscript\" ? document.body : elt);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t* @param {Element} elt\n\t* @param {Element} [target]\n\t*/\n\tfunction initElement(elt, target) {\n\t\tif (elt.closest && elt.closest(_hyperscript.config.disableSelector)) {\n\t\t\treturn;\n\t\t}\n\t\tvar internalData = getInternalData(elt);\n\t\tif (!internalData.initialized) {\n\t\t\tvar src = getScript(elt);\n\t\t\tif (src) {\n\t\t\t\ttry {\n\t\t\t\t\tinternalData.initialized = true;\n\t\t\t\t\tinternalData.script = src;\n\t\t\t\t\tvar tokens = _lexer.tokenize(src);\n\t\t\t\t\tvar hyperScript = _parser.parseHyperScript(tokens);\n\t\t\t\t\tif (!hyperScript) return;\n\t\t\t\t\thyperScript.apply(target || elt, elt);\n\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\ttriggerEvent(target || elt, \"load\", {\n\t\t\t\t\t\t\thyperscript: true,\n\t\t\t\t\t\t});\n\t\t\t\t\t}, 1);\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_runtime.triggerEvent(elt, \"exception\", {\n\t\t\t\t\t\terror: e,\n\t\t\t\t\t});\n\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t\"hyperscript errors were found on the following element:\",\n\t\t\t\t\t\telt,\n\t\t\t\t\t\t\"\\n\\n\",\n\t\t\t\t\t\te.message,\n\t\t\t\t\t\te.stack\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvar internalDataMap = new WeakMap\n\n\t/**\n\t* @param {Element} elt\n\t* @returns {Object}\n\t*/\n\tfunction getInternalData(elt) {\n\t\tvar internalData = internalDataMap.get(elt);\n\t\tif (typeof internalData === 'undefined') {\n\t\t\tinternalDataMap.set(elt, internalData = {});\n\t\t}\n\t\treturn internalData;\n\t}\n\n\t/**\n\t* @param {any} value\n\t* @param {string} typeString\n\t* @param {boolean} [nullOk]\n\t* @returns {boolean}\n\t*/\n\tfunction typeCheck(value, typeString, nullOk) {\n\t\tif (value == null && nullOk) {\n\t\t\treturn true;\n\t\t}\n\t\tvar typeName = Object.prototype.toString.call(value).slice(8, -1);\n\t\treturn typeName === typeString;\n\t}\n\n\tfunction getElementScope(context) {\n\t\tvar elt = context.meta && context.meta.owner;\n\t\tif (elt) {\n\t\t\tvar internalData = getInternalData(elt);\n\t\t\tvar scopeName = \"elementScope\";\n\t\t\tif (context.meta.feature && context.meta.feature.behavior) {\n\t\t\t\tscopeName = context.meta.feature.behavior + \"Scope\";\n\t\t\t}\n\t\t\tvar elementScope = getOrInitObject(internalData, scopeName);\n\t\t\treturn elementScope;\n\t\t} else {\n\t\t\treturn {}; // no element, return empty scope\n\t\t}\n\t}\n\n\t/**\n\t* @param {string} str\n\t* @param {Context} context\n\t* @returns {any}\n\t*/\n\tfunction resolveSymbol(str, context, type) {\n\t\tif (str === \"me\" || str === \"my\" || str === \"I\") {\n\t\t\treturn context[\"me\"];\n\t\t}\n\t\tif (str === \"it\" || str === \"its\") {\n\t\t\treturn context[\"result\"];\n\t\t}\n\t\tif (str === \"you\" || str === \"your\" || str === \"yourself\") {\n\t\t\treturn context[\"beingTold\"];\n\t\t} else {\n\t\t\tif (type === \"global\") {\n\t\t\t\treturn globalScope[str];\n\t\t\t} else if (type === \"element\") {\n\t\t\t\tvar elementScope = getElementScope(context);\n\t\t\t\treturn elementScope[str];\n\t\t\t} else if (type === \"local\") {\n\t\t\t\treturn context[str];\n\t\t\t} else {\n\t\t\t\t// meta scope (used for event conditionals)\n\t\t\t\tif (context.meta && context.meta.context) {\n\t\t\t\t\tvar fromMetaContext = context.meta.context[str];\n\t\t\t\t\tif (typeof fromMetaContext !== \"undefined\") {\n\t\t\t\t\t\treturn fromMetaContext;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// local scope\n\t\t\t\tvar fromContext = context[str];\n\t\t\t\tif (typeof fromContext !== \"undefined\") {\n\t\t\t\t\treturn fromContext;\n\t\t\t\t} else {\n\t\t\t\t\t// element scope\n\t\t\t\t\tvar elementScope = getElementScope(context);\n\t\t\t\t\tfromContext = elementScope[str];\n\t\t\t\t\tif (typeof fromContext !== \"undefined\") {\n\t\t\t\t\t\treturn fromContext;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// global scope\n\t\t\t\t\t\treturn globalScope[str];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction setSymbol(str, context, type, value) {\n\t\tif (type === \"global\") {\n\t\t\tglobalScope[str] = value;\n\t\t} else if (type === \"element\") {\n\t\t\tvar elementScope = getElementScope(context);\n\t\t\telementScope[str] = value;\n\t\t} else if (type === \"local\") {\n\t\t\tcontext[str] = value;\n\t\t} else {\n\t\t\t// local scope\n\t\t\tvar fromContext = context[str];\n\t\t\tif (typeof fromContext !== \"undefined\") {\n\t\t\t\tcontext[str] = value;\n\t\t\t} else {\n\t\t\t\t// element scope\n\t\t\t\tvar elementScope = getElementScope(context);\n\t\t\t\tfromContext = elementScope[str];\n\t\t\t\tif (typeof fromContext !== \"undefined\") {\n\t\t\t\t\telementScope[str] = value;\n\t\t\t\t} else {\n\t\t\t\t\tcontext[str] = value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t* @param {GrammarElement} command\n\t* @param {Context} context\n\t* @returns {undefined | GrammarElement}\n\t*/\n\tfunction findNext(command, context) {\n\t\tif (command) {\n\t\t\tif (command.resolveNext) {\n\t\t\t\treturn command.resolveNext(context);\n\t\t\t} else if (command.next) {\n\t\t\t\treturn command.next;\n\t\t\t} else {\n\t\t\t\treturn findNext(command.parent, context);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t* @param {Object<string,any>} root\n\t* @param {string} property\n\t* @param {boolean} attribute\n\t* @returns {any}\n\t*/\n\tfunction flatGet(root, property, getter) {\n\t\tif (root != null) {\n\t\t\tvar val = getter(root, property);\n\t\t\tif (typeof val !== \"undefined\") {\n\t\t\t\treturn val;\n\t\t\t}\n\n\t\t\tif (shouldAutoIterate(root)) {\n\t\t\t\t// flat map\n\t\t\t\tvar result = [];\n\t\t\t\tfor (var component of root) {\n\t\t\t\t\tvar componentValue = getter(component, property);\n\t\t\t\t\tif (componentValue) {\n\t\t\t\t\t\tresult.push(componentValue);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction resolveProperty(root, property) {\n\t\treturn flatGet(root, property, (root, property) => root[property] )\n\t}\n\n\tfunction resolveAttribute(root, property) {\n\t\treturn flatGet(root, property, (root, property) => root.getAttribute && root.getAttribute(property) )\n\t}\n\n\t/**\n\t *\n\t * @param {Object<string, any>} root\n\t * @param {string} property\n\t * @returns {string}\n\t */\n\tfunction resolveStyle(root, property) {\n\t\treturn flatGet(root, property, (root, property) => root.style && root.style[property] )\n\t}\n\n\t/**\n\t *\n\t * @param {Object<string, any>} root\n\t * @param {string} property\n\t * @returns {string}\n\t */\n\tfunction resolveComputedStyle(root, property) {\n\t\treturn flatGet(root, property, (root, property) => getComputedStyle(root).getPropertyValue(property) )\n\t}\n\n\t/**\n\t* @param {Element} elt\n\t* @param {string[]} nameSpace\n\t* @param {string} name\n\t* @param {any} value\n\t*/\n\tfunction assignToNamespace(elt, nameSpace, name, value) {\n\t\tlet root\n\t\tif (typeof document !== \"undefined\" && elt === document.body) {\n\t\t\troot = globalScope;\n\t\t} else {\n\t\t\troot = getHyperscriptFeatures(elt);\n\t\t}\n\t\twhile (nameSpace.length > 0) {\n\t\t\tvar propertyName = nameSpace.shift();\n\t\t\tvar newRoot = root[propertyName];\n\t\t\tif (newRoot == null) {\n\t\t\t\tnewRoot = {};\n\t\t\t\troot[propertyName] = newRoot;\n\t\t\t}\n\t\t\troot = newRoot;\n\t\t}\n\n\t\troot[name] = value;\n\t}\n\n\tfunction getHyperTrace(ctx, thrown) {\n\t\tvar trace = [];\n\t\tvar root = ctx;\n\t\twhile (root.meta.caller) {\n\t\t\troot = root.meta.caller;\n\t\t}\n\t\tif (root.meta.traceMap) {\n\t\t\treturn root.meta.traceMap.get(thrown, trace);\n\t\t}\n\t}\n\n\tfunction registerHyperTrace(ctx, thrown) {\n\t\tvar trace = [];\n\t\tvar root = null;\n\t\twhile (ctx != null) {\n\t\t\ttrace.push(ctx);\n\t\t\troot = ctx;\n\t\t\tctx = ctx.meta.caller;\n\t\t}\n\t\tif (root.meta.traceMap == null) {\n\t\t\troot.meta.traceMap = new Map(); // TODO - WeakMap?\n\t\t}\n\t\tif (!root.meta.traceMap.get(thrown)) {\n\t\t\tvar traceEntry = {\n\t\t\t\ttrace: trace,\n\t\t\t\tprint: function (logger) {\n\t\t\t\t\tlogger = logger || console.error;\n\t\t\t\t\tlogger(\"hypertrace /// \");\n\t\t\t\t\tvar maxLen = 0;\n\t\t\t\t\tfor (var i = 0; i < trace.length; i++) {\n\t\t\t\t\t\tmaxLen = Math.max(maxLen, trace[i].meta.feature.displayName.length);\n\t\t\t\t\t}\n\t\t\t\t\tfor (var i = 0; i < trace.length; i++) {\n\t\t\t\t\t\tvar traceElt = trace[i];\n\t\t\t\t\t\tlogger(\n\t\t\t\t\t\t\t\"  ->\",\n\t\t\t\t\t\t\ttraceElt.meta.feature.displayName.padEnd(maxLen + 2),\n\t\t\t\t\t\t\t\"-\",\n\t\t\t\t\t\t\ttraceElt.meta.owner\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t};\n\t\t\troot.meta.traceMap.set(thrown, traceEntry);\n\t\t}\n\t}\n\n\t/**\n\t* @param {string} str\n\t* @returns {string}\n\t*/\n\tfunction escapeSelector(str) {\n\t\treturn str.replace(/:/g, function (str) {\n\t\t\treturn \"\\\\\" + str;\n\t\t});\n\t}\n\n\t/**\n\t* @param {any} value\n\t* @param {*} elt\n\t*/\n\tfunction nullCheck(value, elt) {\n\t\tif (value == null) {\n\t\t\tthrow new Error(\"'\" + elt.sourceFor() + \"' is null\");\n\t\t}\n\t}\n\n\t/**\n\t* @param {any} value\n\t* @returns {boolean}\n\t*/\n\tfunction isEmpty(value) {\n\t\treturn value == undefined || value.length === 0;\n\t}\n\n\t/**\n\t* @param {any} value\n\t* @returns {boolean}\n\t*/\n\tfunction doesExist(value) {\n\t\tif(value == null){\n\t\t\treturn false;\n\t\t}\n\t\tif (shouldAutoIterate(value)) {\n\t\t\tfor (const elt of value) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t* @param {Node} node\n\t* @returns {Document|ShadowRoot}\n\t*/\n\tfunction getRootNode(node) {\n\t\tif (node && node instanceof Node) {\n\t\t\tvar rv = node.getRootNode();\n\t\t\tif (rv instanceof Document || rv instanceof ShadowRoot) return rv;\n\t\t}\n\t\treturn document;\n\t}\n\n\t/**\n\t *\n\t * @param {Element} elt\n\t * @param {GrammarElement} onFeature\n\t * @returns {EventQueue}\n\t */\n\tfunction getEventQueueFor(elt, onFeature) {\n\t\tlet internalData = getInternalData(elt);\n\t\tvar eventQueuesForElt = internalData.eventQueues;\n\t\tif (eventQueuesForElt == null) {\n\t\t\teventQueuesForElt = new Map();\n\t\t\tinternalData.eventQueues = eventQueuesForElt;\n\t\t}\n\t\tvar eventQueueForFeature = eventQueuesForElt.get(onFeature);\n\t\tif (eventQueueForFeature == null) {\n\t\t\teventQueueForFeature = {queue:[], executing:false};\n\t\t\teventQueuesForElt.set(onFeature, eventQueueForFeature);\n\t\t}\n\t\treturn eventQueueForFeature;\n\t}\n\n\t/** @type string | null */\n\t// @ts-ignore\n\tvar hyperscriptUrl = \"document\" in globalScope ? import.meta.url : null;\n\n\t/** @type {RuntimeObject} */\n\treturn {\n\t\ttypeCheck,\n\t\tforEach,\n\t\timplicitLoop,\n\t\tshouldAutoIterate,\n\t\ttriggerEvent,\n\t\tmatchesSelector,\n\t\tgetScript,\n\t\tprocessNode,\n\t\tevaluate,\n\t\tevaluateNoPromise,\n\t\tparse,\n\t\tgetScriptSelector,\n\t\tresolveSymbol,\n\t\tsetSymbol,\n\t\tmakeContext,\n\t\tfindNext,\n\t\tunifiedEval,\n\t\tconvertValue,\n\t\tunifiedExec,\n\t\tresolveProperty,\n\t\tresolveAttribute,\n\t\tresolveStyle,\n\t\tresolveComputedStyle,\n\t\tassignToNamespace,\n\t\tregisterHyperTrace,\n\t\tgetHyperTrace,\n\t\tgetInternalData,\n\t\tgetHyperscriptFeatures,\n\t\tescapeSelector,\n\t\tnullCheck,\n\t\tisEmpty,\n\t\tdoesExist,\n\t\tgetRootNode,\n\t\tgetEventQueueFor,\n\t\thyperscriptUrl,\n\t\tHALT,\n\t};\n})();\n\n//====================================================================\n// Grammar\n//====================================================================\n{\n\t_parser.addLeafExpression(\"parenthesized\", function (parser, _runtime, tokens) {\n\t\tif (tokens.matchOpToken(\"(\")) {\n\t\t\tvar follows = tokens.clearFollow();\n\t\t\ttry {\n\t\t\t\tvar expr = parser.requireElement(\"expression\", tokens);\n\t\t\t} finally {\n\t\t\t\ttokens.restoreFollow(follows);\n\t\t\t}\n\t\t\ttokens.requireOpToken(\")\");\n\t\t\treturn expr;\n\t\t}\n\t});\n\n\t_parser.addLeafExpression(\"string\", function (parser, runtime, tokens) {\n\t\tvar stringToken = tokens.matchTokenType(\"STRING\");\n\t\tif (!stringToken) return;\n\t\tvar rawValue = stringToken.value;\n\t\t/** @type {any[]} */\n\t\tvar args;\n\t\tif (stringToken.template) {\n\t\t\tvar innerTokens = _lexer.tokenize(rawValue, true);\n\t\t\targs = parser.parseStringTemplate(innerTokens);\n\t\t} else {\n\t\t\targs = [];\n\t\t}\n\t\treturn {\n\t\t\ttype: \"string\",\n\t\t\ttoken: stringToken,\n\t\t\targs: args,\n\t\t\top: function (context) {\n\t\t\t\tvar returnStr = \"\";\n\t\t\t\tfor (var i = 1; i < arguments.length; i++) {\n\t\t\t\t\tvar val = arguments[i];\n\t\t\t\t\tif (val !== undefined) {\n\t\t\t\t\t\treturnStr += val;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn returnStr;\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\tif (args.length === 0) {\n\t\t\t\t\treturn rawValue;\n\t\t\t\t} else {\n\t\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t\t}\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addGrammarElement(\"nakedString\", function (parser, runtime, tokens) {\n\t\tif (tokens.hasMore()) {\n\t\t\tvar tokenArr = tokens.consumeUntilWhitespace();\n\t\t\ttokens.matchTokenType(\"WHITESPACE\");\n\t\t\treturn {\n\t\t\t\ttype: \"nakedString\",\n\t\t\t\ttokens: tokenArr,\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn tokenArr\n\t\t\t\t\t\t.map(function (t) {\n\t\t\t\t\t\t\treturn t.value;\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.join(\"\");\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t});\n\n\t_parser.addLeafExpression(\"number\", function (parser, runtime, tokens) {\n\t\tvar number = tokens.matchTokenType(\"NUMBER\");\n\t\tif (!number) return;\n\t\tvar numberToken = number;\n\t\tvar value = parseFloat(number.value);\n\t\treturn {\n\t\t\ttype: \"number\",\n\t\t\tvalue: value,\n\t\t\tnumberToken: numberToken,\n\t\t\tevaluate: function () {\n\t\t\t\treturn value;\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addLeafExpression(\"idRef\", function (parser, runtime, tokens) {\n\t\tvar elementId = tokens.matchTokenType(\"ID_REF\");\n\t\tif (!elementId) return;\n\t\t// TODO - unify these two expression types\n\t\tif (elementId.template) {\n\t\t\tvar templateValue = elementId.value.substr(2, elementId.value.length - 2);\n\t\t\tvar innerTokens = _lexer.tokenize(templateValue);\n\t\t\tvar innerExpression = parser.requireElement(\"expression\", innerTokens);\n\t\t\treturn {\n\t\t\t\ttype: \"idRefTemplate\",\n\t\t\t\targs: [innerExpression],\n\t\t\t\top: function (context, arg) {\n\t\t\t\t\treturn runtime.getRootNode(context.me).getElementById(arg);\n\t\t\t\t},\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t} else {\n\t\t\tconst value = elementId.value.substr(1);\n\t\t\treturn {\n\t\t\t\ttype: \"idRef\",\n\t\t\t\tcss: elementId.value,\n\t\t\t\tvalue: value,\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn (\n\t\t\t\t\t\truntime.getRootNode(context.me).getElementById(value)\n\t\t\t\t\t);\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t});\n\n\t_parser.addLeafExpression(\"classRef\", function (parser, runtime, tokens) {\n\t\tvar classRef = tokens.matchTokenType(\"CLASS_REF\");\n\n\t\tif (!classRef) return;\n\n\t\t// TODO - unify these two expression types\n\t\tif (classRef.template) {\n\t\t\tvar templateValue = classRef.value.substr(2, classRef.value.length - 2);\n\t\t\tvar innerTokens = _lexer.tokenize(templateValue);\n\t\t\tvar innerExpression = parser.requireElement(\"expression\", innerTokens);\n\t\t\treturn {\n\t\t\t\ttype: \"classRefTemplate\",\n\t\t\t\targs: [innerExpression],\n\t\t\t\top: function (context, arg) {\n\t\t\t\t\treturn new ElementCollection(\".\" + arg, context.me, true)\n\t\t\t\t},\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t} else {\n\t\t\tconst css = classRef.value;\n\t\t\treturn {\n\t\t\t\ttype: \"classRef\",\n\t\t\t\tcss: css,\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn new ElementCollection(css, context.me, true)\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t});\n\n\tclass TemplatedQueryElementCollection extends ElementCollection {\n\t\tconstructor(css, relativeToElement, templateParts) {\n\t\t\tsuper(css, relativeToElement);\n\t\t\tthis.templateParts = templateParts;\n\t\t\tthis.elements = templateParts.filter(elt => elt instanceof Element);\n\t\t}\n\n\t\tget css() {\n\t\t\tlet rv = \"\", i = 0\n\t\t\tfor (const val of this.templateParts) {\n\t\t\t\tif (val instanceof Element) {\n\t\t\t\t\trv += \"[data-hs-query-id='\" + i++ + \"']\";\n\t\t\t\t} else rv += val;\n\t\t\t}\n\t\t\treturn rv;\n\t\t}\n\n\t\t[Symbol.iterator]() {\n\t\t\tthis.elements.forEach((el, i) => el.dataset.hsQueryId = i);\n\t\t\tconst rv = super[Symbol.iterator]();\n\t\t\tthis.elements.forEach(el => el.removeAttribute('data-hs-query-id'));\n\t\t\treturn rv;\n\t\t}\n\t}\n\n\t_parser.addLeafExpression(\"queryRef\", function (parser, runtime, tokens) {\n\t\tvar queryStart = tokens.matchOpToken(\"<\");\n\t\tif (!queryStart) return;\n\t\tvar queryTokens = tokens.consumeUntil(\"/\");\n\t\ttokens.requireOpToken(\"/\");\n\t\ttokens.requireOpToken(\">\");\n\t\tvar queryValue = queryTokens\n\t\t\t.map(function (t) {\n\t\t\t\tif (t.type === \"STRING\") {\n\t\t\t\t\treturn '\"' + t.value + '\"';\n\t\t\t\t} else {\n\t\t\t\t\treturn t.value;\n\t\t\t\t}\n\t\t\t})\n\t\t\t.join(\"\");\n\n\t\tif (queryValue.indexOf(\"$\") >= 0) {\n\t\t\tvar template = true;\n\t\t\tvar innerTokens = _lexer.tokenize(queryValue, true);\n\t\t\tvar args = parser.parseStringTemplate(innerTokens);\n\t\t}\n\n\t\treturn {\n\t\t\ttype: \"queryRef\",\n\t\t\tcss: queryValue,\n\t\t\targs: args,\n\t\t\top: function (context, ...args) {\n\t\t\t\tif (template) {\n\t\t\t\t\treturn new TemplatedQueryElementCollection(queryValue, context.me, args)\n\t\t\t\t} else {\n\t\t\t\t\treturn new ElementCollection(queryValue, context.me)\n\t\t\t\t}\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addLeafExpression(\"attributeRef\", function (parser, runtime, tokens) {\n\t\tvar attributeRef = tokens.matchTokenType(\"ATTRIBUTE_REF\");\n\t\tif (!attributeRef) return;\n\t\tvar outerVal = attributeRef.value;\n\t\tif (outerVal.indexOf(\"[\") === 0) {\n\t\t\tvar innerValue = outerVal.substring(2, outerVal.length - 1);\n\t\t} else {\n\t\t\tvar innerValue = outerVal.substring(1);\n\t\t}\n\t\tvar css = \"[\" + innerValue + \"]\";\n\t\tvar split = innerValue.split(\"=\");\n\t\tvar name = split[0];\n\t\tvar value = split[1];\n\t\tif (value) {\n\t\t\t// strip quotes\n\t\t\tif (value.indexOf('\"') === 0) {\n\t\t\t\tvalue = value.substring(1, value.length - 1);\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\ttype: \"attributeRef\",\n\t\t\tname: name,\n\t\t\tcss: css,\n\t\t\tvalue: value,\n\t\t\top: function (context) {\n\t\t\t\tvar target = context.beingTold || context.me;\n\t\t\t\tif (target) {\n\t\t\t\t\treturn target.getAttribute(name);\n\t\t\t\t}\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addLeafExpression(\"styleRef\", function (parser, runtime, tokens) {\n\t\tvar styleRef = tokens.matchTokenType(\"STYLE_REF\");\n\t\tif (!styleRef) return;\n\t\tvar styleProp = styleRef.value.substr(1);\n\t\tif (styleProp.startsWith(\"computed-\")) {\n\t\t\tstyleProp = styleProp.substr(\"computed-\".length);\n\t\t\treturn {\n\t\t\t\ttype: \"computedStyleRef\",\n\t\t\t\tname: styleProp,\n\t\t\t\top: function (context) {\n\t\t\t\t\tvar target = context.beingTold || context.me;\n\t\t\t\t\tif (target) {\n\t\t\t\t\t\treturn runtime.resolveComputedStyle(target, styleProp);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t} else {\n\t\t\treturn {\n\t\t\t\ttype: \"styleRef\",\n\t\t\t\tname: styleProp,\n\t\t\t\top: function (context) {\n\t\t\t\t\tvar target = context.beingTold || context.me;\n\t\t\t\t\tif (target) {\n\t\t\t\t\t\treturn runtime.resolveStyle(target, styleProp);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t});\n\n\t_parser.addGrammarElement(\"objectKey\", function (parser, runtime, tokens) {\n\t\tvar token;\n\t\tif ((token = tokens.matchTokenType(\"STRING\"))) {\n\t\t\treturn {\n\t\t\t\ttype: \"objectKey\",\n\t\t\t\tkey: token.value,\n\t\t\t\tevaluate: function () {\n\t\t\t\t\treturn token.value;\n\t\t\t\t},\n\t\t\t};\n\t\t} else if (tokens.matchOpToken(\"[\")) {\n\t\t\tvar expr = parser.parseElement(\"expression\", tokens);\n\t\t\ttokens.requireOpToken(\"]\");\n\t\t\treturn {\n\t\t\t\ttype: \"objectKey\",\n\t\t\t\texpr: expr,\n\t\t\t\targs: [expr],\n\t\t\t\top: function (ctx, expr) {\n\t\t\t\t\treturn expr;\n\t\t\t\t},\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t} else {\n\t\t\tvar key = \"\";\n\t\t\tdo {\n\t\t\t\ttoken = tokens.matchTokenType(\"IDENTIFIER\") || tokens.matchOpToken(\"-\");\n\t\t\t\tif (token) key += token.value;\n\t\t\t} while (token);\n\t\t\treturn {\n\t\t\t\ttype: \"objectKey\",\n\t\t\t\tkey: key,\n\t\t\t\tevaluate: function () {\n\t\t\t\t\treturn key;\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t});\n\n\t_parser.addLeafExpression(\"objectLiteral\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchOpToken(\"{\")) return;\n\t\tvar keyExpressions = [];\n\t\tvar valueExpressions = [];\n\t\tif (!tokens.matchOpToken(\"}\")) {\n\t\t\tdo {\n\t\t\t\tvar name = parser.requireElement(\"objectKey\", tokens);\n\t\t\t\ttokens.requireOpToken(\":\");\n\t\t\t\tvar value = parser.requireElement(\"expression\", tokens);\n\t\t\t\tvalueExpressions.push(value);\n\t\t\t\tkeyExpressions.push(name);\n\t\t\t} while (tokens.matchOpToken(\",\"));\n\t\t\ttokens.requireOpToken(\"}\");\n\t\t}\n\t\treturn {\n\t\t\ttype: \"objectLiteral\",\n\t\t\targs: [keyExpressions, valueExpressions],\n\t\t\top: function (context, keys, values) {\n\t\t\t\tvar returnVal = {};\n\t\t\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\t\t\treturnVal[keys[i]] = values[i];\n\t\t\t\t}\n\t\t\t\treturn returnVal;\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addGrammarElement(\"nakedNamedArgumentList\", function (parser, runtime, tokens) {\n\t\tvar fields = [];\n\t\tvar valueExpressions = [];\n\t\tif (tokens.currentToken().type === \"IDENTIFIER\") {\n\t\t\tdo {\n\t\t\t\tvar name = tokens.requireTokenType(\"IDENTIFIER\");\n\t\t\t\ttokens.requireOpToken(\":\");\n\t\t\t\tvar value = parser.requireElement(\"expression\", tokens);\n\t\t\t\tvalueExpressions.push(value);\n\t\t\t\tfields.push({ name: name, value: value });\n\t\t\t} while (tokens.matchOpToken(\",\"));\n\t\t}\n\t\treturn {\n\t\t\ttype: \"namedArgumentList\",\n\t\t\tfields: fields,\n\t\t\targs: [valueExpressions],\n\t\t\top: function (context, values) {\n\t\t\t\tvar returnVal = { _namedArgList_: true };\n\t\t\t\tfor (var i = 0; i < values.length; i++) {\n\t\t\t\t\tvar field = fields[i];\n\t\t\t\t\treturnVal[field.name.value] = values[i];\n\t\t\t\t}\n\t\t\t\treturn returnVal;\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addGrammarElement(\"namedArgumentList\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchOpToken(\"(\")) return;\n\t\tvar elt = parser.requireElement(\"nakedNamedArgumentList\", tokens);\n\t\ttokens.requireOpToken(\")\");\n\t\treturn elt;\n\t});\n\n\t_parser.addGrammarElement(\"symbol\", function (parser, runtime, tokens) {\n\t\t/** @scope {SymbolScope} */\n\t\tvar scope = \"default\";\n\t\tif (tokens.matchToken(\"global\")) {\n\t\t\tscope = \"global\";\n\t\t} else if (tokens.matchToken(\"element\") || tokens.matchToken(\"module\")) {\n\t\t\tscope = \"element\";\n\t\t\t// optional possessive\n\t\t\tif (tokens.matchOpToken(\"'\")) {\n\t\t\t\ttokens.requireToken(\"s\");\n\t\t\t}\n\t\t} else if (tokens.matchToken(\"local\")) {\n\t\t\tscope = \"local\";\n\t\t}\n\n\t\t// TODO better look ahead here\n\t\tlet eltPrefix = tokens.matchOpToken(\":\");\n\t\tlet identifier = tokens.matchTokenType(\"IDENTIFIER\");\n\t\tif (identifier) {\n\t\t\tvar name = identifier.value;\n\t\t\tif (eltPrefix) {\n\t\t\t\tname = \":\" + name;\n\t\t\t}\n\t\t\tif (scope === \"default\") {\n\t\t\t\tif (name.indexOf(\"$\") === 0) {\n\t\t\t\t\tscope = \"global\";\n\t\t\t\t}\n\t\t\t\tif (name.indexOf(\":\") === 0) {\n\t\t\t\t\tscope = \"element\";\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn {\n\t\t\t\ttype: \"symbol\",\n\t\t\t\ttoken: identifier,\n\t\t\t\tscope: scope,\n\t\t\t\tname: name,\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn runtime.resolveSymbol(name, context, scope);\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t});\n\n\t_parser.addGrammarElement(\"implicitMeTarget\", function (parser, runtime, tokens) {\n\t\treturn {\n\t\t\ttype: \"implicitMeTarget\",\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn context.beingTold || context.me;\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addLeafExpression(\"boolean\", function (parser, runtime, tokens) {\n\t\tvar booleanLiteral = tokens.matchToken(\"true\") || tokens.matchToken(\"false\");\n\t\tif (!booleanLiteral) return;\n\t\tconst value = booleanLiteral.value === \"true\";\n\t\treturn {\n\t\t\ttype: \"boolean\",\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn value;\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addLeafExpression(\"null\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"null\")) {\n\t\t\treturn {\n\t\t\t\ttype: \"null\",\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn null;\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t});\n\n\t_parser.addLeafExpression(\"arrayLiteral\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchOpToken(\"[\")) return;\n\t\tvar values = [];\n\t\tif (!tokens.matchOpToken(\"]\")) {\n\t\t\tdo {\n\t\t\t\tvar expr = parser.requireElement(\"expression\", tokens);\n\t\t\t\tvalues.push(expr);\n\t\t\t} while (tokens.matchOpToken(\",\"));\n\t\t\ttokens.requireOpToken(\"]\");\n\t\t}\n\t\treturn {\n\t\t\ttype: \"arrayLiteral\",\n\t\t\tvalues: values,\n\t\t\targs: [values],\n\t\t\top: function (context, values) {\n\t\t\t\treturn values;\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addLeafExpression(\"blockLiteral\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchOpToken(\"\\\\\")) return;\n\t\tvar args = [];\n\t\tvar arg1 = tokens.matchTokenType(\"IDENTIFIER\");\n\t\tif (arg1) {\n\t\t\targs.push(arg1);\n\t\t\twhile (tokens.matchOpToken(\",\")) {\n\t\t\t\targs.push(tokens.requireTokenType(\"IDENTIFIER\"));\n\t\t\t}\n\t\t}\n\t\t// TODO compound op token\n\t\ttokens.requireOpToken(\"-\");\n\t\ttokens.requireOpToken(\">\");\n\t\tvar expr = parser.requireElement(\"expression\", tokens);\n\t\treturn {\n\t\t\ttype: \"blockLiteral\",\n\t\t\targs: args,\n\t\t\texpr: expr,\n\t\t\tevaluate: function (ctx) {\n\t\t\t\tvar returnFunc = function () {\n\t\t\t\t\t//TODO - push scope\n\t\t\t\t\tfor (var i = 0; i < args.length; i++) {\n\t\t\t\t\t\tctx[args[i].value] = arguments[i];\n\t\t\t\t\t}\n\t\t\t\t\treturn expr.evaluate(ctx); //OK\n\t\t\t\t};\n\t\t\t\treturn returnFunc;\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addIndirectExpression(\"propertyAccess\", function (parser, runtime, tokens, root) {\n\t\tif (!tokens.matchOpToken(\".\")) return;\n\t\tvar prop = tokens.requireTokenType(\"IDENTIFIER\");\n\t\tvar propertyAccess = {\n\t\t\ttype: \"propertyAccess\",\n\t\t\troot: root,\n\t\t\tprop: prop,\n\t\t\targs: [root],\n\t\t\top: function (_context, rootVal) {\n\t\t\t\tvar value = runtime.resolveProperty(rootVal, prop.value);\n\t\t\t\treturn value;\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\t\treturn parser.parseElement(\"indirectExpression\", tokens, propertyAccess);\n\t});\n\n\t_parser.addIndirectExpression(\"of\", function (parser, runtime, tokens, root) {\n\t\tif (!tokens.matchToken(\"of\")) return;\n\t\tvar newRoot = parser.requireElement(\"unaryExpression\", tokens);\n\t\t// find the urroot\n\t\tvar childOfUrRoot = null;\n\t\tvar urRoot = root;\n\t\twhile (urRoot.root) {\n\t\t\tchildOfUrRoot = urRoot;\n\t\t\turRoot = urRoot.root;\n\t\t}\n\t\tif (urRoot.type !== \"symbol\" && urRoot.type !== \"attributeRef\" && urRoot.type !== \"styleRef\" && urRoot.type !== \"computedStyleRef\") {\n\t\t\tparser.raiseParseError(tokens, \"Cannot take a property of a non-symbol: \" + urRoot.type);\n\t\t}\n\t\tvar attribute = urRoot.type === \"attributeRef\";\n\t\tvar style = urRoot.type === \"styleRef\" || urRoot.type === \"computedStyleRef\";\n\t\tif (attribute || style) {\n\t\t\tvar attributeElt = urRoot\n\t\t}\n\t\tvar prop = urRoot.name;\n\n\t\tvar propertyAccess = {\n\t\t\ttype: \"ofExpression\",\n\t\t\tprop: urRoot.token,\n\t\t\troot: newRoot,\n\t\t\tattribute: attributeElt,\n\t\t\texpression: root,\n\t\t\targs: [newRoot],\n\t\t\top: function (context, rootVal) {\n\t\t\t\tif (attribute) {\n\t\t\t\t\treturn runtime.resolveAttribute(rootVal, prop);\n\t\t\t\t} else if (style) {\n\t\t\t\t\tif (urRoot.type === \"computedStyleRef\") {\n\t\t\t\t\t\treturn runtime.resolveComputedStyle(rootVal, prop);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn runtime.resolveStyle(rootVal, prop);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn runtime.resolveProperty(rootVal, prop);\n\t\t\t\t}\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\n\t\tif (urRoot.type === \"attributeRef\") {\n\t\t\tpropertyAccess.attribute = urRoot;\n\t\t}\n\t\tif (childOfUrRoot) {\n\t\t\tchildOfUrRoot.root = propertyAccess;\n\t\t\tchildOfUrRoot.args = [propertyAccess];\n\t\t} else {\n\t\t\troot = propertyAccess;\n\t\t}\n\n\t\treturn parser.parseElement(\"indirectExpression\", tokens, root);\n\t});\n\n\t_parser.addIndirectExpression(\"possessive\", function (parser, runtime, tokens, root) {\n\t\tif (parser.possessivesDisabled) {\n\t\t\treturn;\n\t\t}\n\t\tvar apostrophe = tokens.matchOpToken(\"'\");\n\t\tif (\n\t\t\tapostrophe ||\n\t\t\t(root.type === \"symbol\" &&\n\t\t\t\t(root.name === \"my\" || root.name === \"its\" || root.name === \"your\") &&\n\t\t\t\t(tokens.currentToken().type === \"IDENTIFIER\" || tokens.currentToken().type === \"ATTRIBUTE_REF\" || tokens.currentToken().type === \"STYLE_REF\"))\n\t\t) {\n\t\t\tif (apostrophe) {\n\t\t\t\ttokens.requireToken(\"s\");\n\t\t\t}\n\t\t\tvar attribute = parser.parseElement(\"attributeRef\", tokens);\n\t\t\tif (attribute == null) {\n\t\t\t\tvar style = parser.parseElement(\"styleRef\", tokens);\n\t\t\t\tif (style == null) {\n\t\t\t\t\tvar prop = tokens.requireTokenType(\"IDENTIFIER\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar propertyAccess = {\n\t\t\t\ttype: \"possessive\",\n\t\t\t\troot: root,\n\t\t\t\tattribute: attribute || style,\n\t\t\t\tprop: prop,\n\t\t\t\targs: [root],\n\t\t\t\top: function (context, rootVal) {\n\t\t\t\t\tif (attribute) {\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\tvar value = runtime.resolveAttribute(rootVal, attribute.name);\n\t\t\t\t\t} else if (style) {\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\tif (style.type === 'computedStyleRef') {\n\t\t\t\t\t\t\tvar value = runtime.resolveComputedStyle(rootVal, style.name);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvar value = runtime.resolveStyle(rootVal, style.name);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar value = runtime.resolveProperty(rootVal, prop.value);\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t},\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t\treturn parser.parseElement(\"indirectExpression\", tokens, propertyAccess);\n\t\t}\n\t});\n\n\t_parser.addIndirectExpression(\"inExpression\", function (parser, runtime, tokens, root) {\n\t\tif (!tokens.matchToken(\"in\")) return;\n\t\tvar target = parser.requireElement(\"unaryExpression\", tokens);\n\t\tvar propertyAccess = {\n\t\t\ttype: \"inExpression\",\n\t\t\troot: root,\n\t\t\targs: [root, target],\n\t\t\top: function (context, rootVal, target) {\n\t\t\t\tvar returnArr = [];\n\t\t\t\tif (rootVal.css) {\n\t\t\t\t\truntime.implicitLoop(target, function (targetElt) {\n\t\t\t\t\t\tvar results = targetElt.querySelectorAll(rootVal.css);\n\t\t\t\t\t\tfor (var i = 0; i < results.length; i++) {\n\t\t\t\t\t\t\treturnArr.push(results[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else if (rootVal instanceof Element) {\n\t\t\t\t\tvar within = false;\n\t\t\t\t\truntime.implicitLoop(target, function (targetElt) {\n\t\t\t\t\t\tif (targetElt.contains(rootVal)) {\n\t\t\t\t\t\t\twithin = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tif(within) {\n\t\t\t\t\t\treturn rootVal;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\truntime.implicitLoop(rootVal, function (rootElt) {\n\t\t\t\t\t\truntime.implicitLoop(target, function (targetElt) {\n\t\t\t\t\t\t\tif (rootElt === targetElt) {\n\t\t\t\t\t\t\t\treturnArr.push(rootElt);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn returnArr;\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\t\treturn parser.parseElement(\"indirectExpression\", tokens, propertyAccess);\n\t});\n\n\t_parser.addIndirectExpression(\"asExpression\", function (parser, runtime, tokens, root) {\n\t\tif (!tokens.matchToken(\"as\")) return;\n\t\ttokens.matchToken(\"a\") || tokens.matchToken(\"an\");\n\t\tvar conversion = parser.requireElement(\"dotOrColonPath\", tokens).evaluate(); // OK No promise\n\t\tvar propertyAccess = {\n\t\t\ttype: \"asExpression\",\n\t\t\troot: root,\n\t\t\targs: [root],\n\t\t\top: function (context, rootVal) {\n\t\t\t\treturn runtime.convertValue(rootVal, conversion);\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\t\treturn parser.parseElement(\"indirectExpression\", tokens, propertyAccess);\n\t});\n\n\t_parser.addIndirectExpression(\"functionCall\", function (parser, runtime, tokens, root) {\n\t\tif (!tokens.matchOpToken(\"(\")) return;\n\t\tvar args = [];\n\t\tif (!tokens.matchOpToken(\")\")) {\n\t\t\tdo {\n\t\t\t\targs.push(parser.requireElement(\"expression\", tokens));\n\t\t\t} while (tokens.matchOpToken(\",\"));\n\t\t\ttokens.requireOpToken(\")\");\n\t\t}\n\n\t\tif (root.root) {\n\t\t\tvar functionCall = {\n\t\t\t\ttype: \"functionCall\",\n\t\t\t\troot: root,\n\t\t\t\targExressions: args,\n\t\t\t\targs: [root.root, args],\n\t\t\t\top: function (context, rootRoot, args) {\n\t\t\t\t\truntime.nullCheck(rootRoot, root.root);\n\t\t\t\t\tvar func = rootRoot[root.prop.value];\n\t\t\t\t\truntime.nullCheck(func, root);\n\t\t\t\t\tif (func.hyperfunc) {\n\t\t\t\t\t\targs.push(context);\n\t\t\t\t\t}\n\t\t\t\t\treturn func.apply(rootRoot, args);\n\t\t\t\t},\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t} else {\n\t\t\tvar functionCall = {\n\t\t\t\ttype: \"functionCall\",\n\t\t\t\troot: root,\n\t\t\t\targExressions: args,\n\t\t\t\targs: [root, args],\n\t\t\t\top: function (context, func, argVals) {\n\t\t\t\t\truntime.nullCheck(func, root);\n\t\t\t\t\tif (func.hyperfunc) {\n\t\t\t\t\t\targVals.push(context);\n\t\t\t\t\t}\n\t\t\t\t\tvar apply = func.apply(null, argVals);\n\t\t\t\t\treturn apply;\n\t\t\t\t},\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t\treturn parser.parseElement(\"indirectExpression\", tokens, functionCall);\n\t});\n\n\t_parser.addIndirectExpression(\"attributeRefAccess\", function (parser, runtime, tokens, root) {\n\t\tvar attribute = parser.parseElement(\"attributeRef\", tokens);\n\t\tif (!attribute) return;\n\t\tvar attributeAccess = {\n\t\t\ttype: \"attributeRefAccess\",\n\t\t\troot: root,\n\t\t\tattribute: attribute,\n\t\t\targs: [root],\n\t\t\top: function (_ctx, rootVal) {\n\t\t\t\t// @ts-ignore\n\t\t\t\tvar value = runtime.resolveAttribute(rootVal, attribute.name);\n\t\t\t\treturn value;\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn _runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\t\treturn attributeAccess;\n\t});\n\n\t_parser.addIndirectExpression(\"arrayIndex\", function (parser, runtime, tokens, root) {\n\t\tif (!tokens.matchOpToken(\"[\")) return;\n\t\tvar andBefore = false;\n\t\tvar andAfter = false;\n\t\tvar firstIndex = null;\n\t\tvar secondIndex = null;\n\n\t\tif (tokens.matchOpToken(\"..\")) {\n\t\t\tandBefore = true;\n\t\t\tfirstIndex = parser.requireElement(\"expression\", tokens);\n\t\t} else {\n\t\t\tfirstIndex = parser.requireElement(\"expression\", tokens);\n\n\t\t\tif (tokens.matchOpToken(\"..\")) {\n\t\t\t\tandAfter = true;\n\t\t\t\tvar current = tokens.currentToken();\n\t\t\t\tif (current.type !== \"R_BRACKET\") {\n\t\t\t\t\tsecondIndex = parser.parseElement(\"expression\", tokens);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttokens.requireOpToken(\"]\");\n\n\t\tvar arrayIndex = {\n\t\t\ttype: \"arrayIndex\",\n\t\t\troot: root,\n\t\t\tprop: firstIndex,\n\t\t\tfirstIndex: firstIndex,\n\t\t\tsecondIndex: secondIndex,\n\t\t\targs: [root, firstIndex, secondIndex],\n\t\t\top: function (_ctx, root, firstIndex, secondIndex) {\n\t\t\t\tif (root == null) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tif (andBefore) {\n\t\t\t\t\tif (firstIndex < 0) {\n\t\t\t\t\t\tfirstIndex = root.length + firstIndex;\n\t\t\t\t\t}\n\t\t\t\t\treturn root.slice(0, firstIndex + 1); // returns all items from beginning to firstIndex (inclusive)\n\t\t\t\t} else if (andAfter) {\n\t\t\t\t\tif (secondIndex != null) {\n\t\t\t\t\t\tif (secondIndex < 0) {\n\t\t\t\t\t\t\tsecondIndex = root.length + secondIndex;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn root.slice(firstIndex, secondIndex + 1); // returns all items from firstIndex to secondIndex (inclusive)\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn root.slice(firstIndex); // returns from firstIndex to end of array\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn root[firstIndex];\n\t\t\t\t}\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn _runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\n\t\treturn _parser.parseElement(\"indirectExpression\", tokens, arrayIndex);\n\t});\n\n\t// taken from https://drafts.csswg.org/css-values-4/#relative-length\n\t//        and https://drafts.csswg.org/css-values-4/#absolute-length\n\t//        (NB: we do not support `in` dues to conflicts w/ the hyperscript grammar)\n\tvar STRING_POSTFIXES = [\n\t\t'em', 'ex', 'cap', 'ch', 'ic', 'rem', 'lh', 'rlh', 'vw', 'vh', 'vi', 'vb', 'vmin', 'vmax',\n\t\t'cm', 'mm', 'Q', 'pc', 'pt', 'px'\n\t];\n\t_parser.addGrammarElement(\"postfixExpression\", function (parser, runtime, tokens) {\n\t\tvar root = parser.parseElement(\"primaryExpression\", tokens);\n\n\t\tlet stringPosfix = tokens.matchAnyToken.apply(tokens, STRING_POSTFIXES) || tokens.matchOpToken(\"%\");\n\t\tif (stringPosfix) {\n\t\t\treturn {\n\t\t\t\ttype: \"stringPostfix\",\n\t\t\t\tpostfix: stringPosfix.value,\n\t\t\t\targs: [root],\n\t\t\t\top: function (context, val) {\n\t\t\t\t\treturn \"\" + val + stringPosfix.value;\n\t\t\t\t},\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\n\t\tvar timeFactor = null;\n\t\tif (tokens.matchToken(\"s\") || tokens.matchToken(\"seconds\")) {\n\t\t\ttimeFactor = 1000;\n\t\t} else if (tokens.matchToken(\"ms\") || tokens.matchToken(\"milliseconds\")) {\n\t\t\ttimeFactor = 1;\n\t\t}\n\t\tif (timeFactor) {\n\t\t\treturn {\n\t\t\t\ttype: \"timeExpression\",\n\t\t\t\ttime: root,\n\t\t\t\tfactor: timeFactor,\n\t\t\t\targs: [root],\n\t\t\t\top: function (_context, val) {\n\t\t\t\t\treturn val * timeFactor;\n\t\t\t\t},\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\n\t\tif (tokens.matchOpToken(\":\")) {\n\t\t\tvar typeName = tokens.requireTokenType(\"IDENTIFIER\");\n\t\t\tvar nullOk = !tokens.matchOpToken(\"!\");\n\t\t\treturn {\n\t\t\t\ttype: \"typeCheck\",\n\t\t\t\ttypeName: typeName,\n\t\t\t\tnullOk: nullOk,\n\t\t\t\targs: [root],\n\t\t\t\top: function (context, val) {\n\t\t\t\t\tvar passed = runtime.typeCheck(val, typeName.value, nullOk);\n\t\t\t\t\tif (passed) {\n\t\t\t\t\t\treturn val;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error(\"Typecheck failed!  Expected: \" + typeName.value);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t} else {\n\t\t\treturn root;\n\t\t}\n\t});\n\n\t_parser.addGrammarElement(\"logicalNot\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"not\")) return;\n\t\tvar root = parser.requireElement(\"unaryExpression\", tokens);\n\t\treturn {\n\t\t\ttype: \"logicalNot\",\n\t\t\troot: root,\n\t\t\targs: [root],\n\t\t\top: function (context, val) {\n\t\t\t\treturn !val;\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addGrammarElement(\"noExpression\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"no\")) return;\n\t\tvar root = parser.requireElement(\"unaryExpression\", tokens);\n\t\treturn {\n\t\t\ttype: \"noExpression\",\n\t\t\troot: root,\n\t\t\targs: [root],\n\t\t\top: function (_context, val) {\n\t\t\t\treturn runtime.isEmpty(val);\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addLeafExpression(\"some\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"some\")) return;\n\t\tvar root = parser.requireElement(\"expression\", tokens);\n\t\treturn {\n\t\t\ttype: \"noExpression\",\n\t\t\troot: root,\n\t\t\targs: [root],\n\t\t\top: function (_context, val) {\n\t\t\t\treturn !runtime.isEmpty(val);\n\t\t\t},\n\t\t\tevaluate(context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addGrammarElement(\"negativeNumber\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchOpToken(\"-\")) return;\n\t\tvar root = parser.requireElement(\"unaryExpression\", tokens);\n\t\treturn {\n\t\t\ttype: \"negativeNumber\",\n\t\t\troot: root,\n\t\t\targs: [root],\n\t\t\top: function (context, value) {\n\t\t\t\treturn -1 * value;\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addGrammarElement(\"unaryExpression\", function (parser, runtime, tokens) {\n\t\ttokens.matchToken(\"the\"); // optional \"the\"\n\t\treturn parser.parseAnyOf(\n\t\t\t[\"beepExpression\", \"logicalNot\", \"relativePositionalExpression\", \"positionalExpression\", \"noExpression\", \"negativeNumber\", \"postfixExpression\"],\n\t\t\ttokens\n\t\t);\n\t});\n\n\t_parser.addGrammarElement(\"beepExpression\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"beep!\")) return;\n\t\tvar expression = parser.parseElement(\"unaryExpression\", tokens);\n\t\tif (expression) {\n\t\t\texpression.booped = true;\n\t\t\tvar originalEvaluate = expression.evaluate;\n\t\t\texpression.evaluate = function(ctx){\n\t\t\t\tlet value = originalEvaluate.apply(expression, arguments);\n\t\t\t\tlet element = ctx.me;\n\t\t\t\tif (runtime.triggerEvent(element, \"hyperscript:beep\", {element, expression, value})) {\n\t\t\t\t\tvar typeName;\n\t\t\t\t\tif (value) {\n\t\t\t\t\t\tif (value instanceof ElementCollection){\n\t\t\t\t\t\t\ttypeName = \"ElementCollection\";\n\t\t\t\t\t\t} else if (value.constructor) {\n\t\t\t\t\t\t\ttypeName = value.constructor.name;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttypeName = \"unknown\";\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttypeName = \"object (null)\"\n\t\t\t\t\t}\n\t\t\t\t\tvar logValue = value;\n\t\t\t\t\tif (typeName === \"String\") {\n\t\t\t\t\t\tlogValue = '\"' + logValue + '\"';\n\t\t\t\t\t} else if (value instanceof ElementCollection) {\n\t\t\t\t\t\tlogValue = Array.from(value);\n\t\t\t\t\t}\n\t\t\t\t\tconsole.log(\"///_ BEEP! The expression (\" + expression.sourceFor().substr(6) + \") evaluates to:\", logValue,  \"of type \" + typeName);\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\treturn expression;\n\t\t}\n\t});\n\n\tvar scanForwardQuery = function(start, root, match, wrap) {\n\t\tvar results = root.querySelectorAll(match);\n\t\tfor (var i = 0; i < results.length; i++) {\n\t\t\tvar elt = results[i];\n\t\t\tif (elt.compareDocumentPosition(start) === Node.DOCUMENT_POSITION_PRECEDING) {\n\t\t\t\treturn elt;\n\t\t\t}\n\t\t}\n\t\tif (wrap) {\n\t\t\treturn results[0];\n\t\t}\n\t}\n\n\tvar scanBackwardsQuery = function(start, root, match, wrap) {\n\t\tvar results = root.querySelectorAll(match);\n\t\tfor (var i = results.length - 1; i >= 0; i--) {\n\t\t\tvar elt = results[i];\n\t\t\tif (elt.compareDocumentPosition(start) === Node.DOCUMENT_POSITION_FOLLOWING) {\n\t\t\t\treturn elt;\n\t\t\t}\n\t\t}\n\t\tif (wrap) {\n\t\t\treturn results[results.length - 1];\n\t\t}\n\t}\n\n\tvar scanForwardArray = function(start, array, match, wrap) {\n\t\tvar matches = [];\n\t\t_runtime.forEach(array, function(elt){\n\t\t\tif (elt.matches(match) || elt === start) {\n\t\t\t\tmatches.push(elt);\n\t\t\t}\n\t\t})\n\t\tfor (var i = 0; i < matches.length - 1; i++) {\n\t\t\tvar elt = matches[i];\n\t\t\tif (elt === start) {\n\t\t\t\treturn matches[i + 1];\n\t\t\t}\n\t\t}\n\t\tif (wrap) {\n\t\t\tvar first = matches[0];\n\t\t\tif (first && first.matches(match)) {\n\t\t\t\treturn first;\n\t\t\t}\n\t\t}\n\t}\n\n\tvar scanBackwardsArray = function(start, array, match, wrap) {\n\t\treturn scanForwardArray(start, Array.from(array).reverse(), match, wrap);\n\t}\n\n\t_parser.addGrammarElement(\"relativePositionalExpression\", function (parser, runtime, tokens) {\n\t\tvar op = tokens.matchAnyToken(\"next\", \"previous\");\n\t\tif (!op) return;\n\t\tif (op.value === \"next\") {\n\t\t\tvar forwardSearch = true;\n\t\t}\n\n\t\tvar thing = parser.parseElement(\"expression\", tokens);\n\n\t\tif (tokens.matchToken(\"from\")) {\n\t\t\ttokens.pushFollow(\"in\");\n\t\t\ttry {\n\t\t\t\tvar from = parser.requireElement(\"unaryExpression\", tokens);\n\t\t\t} finally {\n\t\t\t\ttokens.popFollow();\n\t\t\t}\n\t\t} else {\n\t\t\tvar from = parser.requireElement(\"implicitMeTarget\", tokens);\n\t\t}\n\n\t\tvar inSearch = false;\n\t\tvar withinElt;\n\t\tif (tokens.matchToken(\"in\")) {\n\t\t\tinSearch = true;\n\t\t\tvar inElt = parser.requireElement(\"unaryExpression\", tokens);\n\t\t} else if (tokens.matchToken(\"within\")) {\n\t\t\twithinElt = parser.requireElement(\"unaryExpression\", tokens);\n\t\t} else {\n\t\t\twithinElt = document.body;\n\t\t}\n\n\t\tvar wrapping = false;\n\t\tif (tokens.matchToken(\"with\")) {\n\t\t\ttokens.requireToken(\"wrapping\")\n\t\t\twrapping = true;\n\t\t}\n\n\t\treturn {\n\t\t\ttype: \"relativePositionalExpression\",\n\t\t\tfrom: from,\n\t\t\tforwardSearch: forwardSearch,\n\t\t\tinSearch: inSearch,\n\t\t\twrapping: wrapping,\n\t\t\tinElt: inElt,\n\t\t\twithinElt: withinElt,\n\t\t\toperator: op.value,\n\t\t\targs: [thing, from, inElt, withinElt],\n\t\t\top: function (context, thing, from, inElt, withinElt) {\n\n\t\t\t\tvar css = thing.css;\n\t\t\t\tif (css == null) {\n\t\t\t\t\tthrow \"Expected a CSS value\";\n\t\t\t\t}\n\n\t\t\t\tif(inSearch) {\n\t\t\t\t\tif (inElt) {\n\t\t\t\t\t\tif (forwardSearch) {\n\t\t\t\t\t\t\treturn scanForwardArray(from, inElt, css, wrapping);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn scanBackwardsArray(from, inElt, css, wrapping);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (withinElt) {\n\t\t\t\t\t\tif (forwardSearch) {\n\t\t\t\t\t\t\treturn scanForwardQuery(from, withinElt, css, wrapping);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn scanBackwardsQuery(from, withinElt, css, wrapping);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t}\n\n\t});\n\n\t_parser.addGrammarElement(\"positionalExpression\", function (parser, runtime, tokens) {\n\t\tvar op = tokens.matchAnyToken(\"first\", \"last\", \"random\");\n\t\tif (!op) return;\n\t\ttokens.matchAnyToken(\"in\", \"from\", \"of\");\n\t\tvar rhs = parser.requireElement(\"unaryExpression\", tokens);\n\t\tconst operator = op.value;\n\t\treturn {\n\t\t\ttype: \"positionalExpression\",\n\t\t\trhs: rhs,\n\t\t\toperator: op.value,\n\t\t\targs: [rhs],\n\t\t\top: function (context, rhsVal) {\n\t\t\t\tif (rhsVal && !Array.isArray(rhsVal)) {\n\t\t\t\t\tif (rhsVal.children) {\n\t\t\t\t\t\trhsVal = rhsVal.children;\n\t\t\t\t\t} else {\n\t\t\t\t\t\trhsVal = Array.from(rhsVal);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (rhsVal) {\n\t\t\t\t\tif (operator === \"first\") {\n\t\t\t\t\t\treturn rhsVal[0];\n\t\t\t\t\t} else if (operator === \"last\") {\n\t\t\t\t\t\treturn rhsVal[rhsVal.length - 1];\n\t\t\t\t\t} else if (operator === \"random\") {\n\t\t\t\t\t\treturn rhsVal[Math.floor(Math.random() * rhsVal.length)];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addGrammarElement(\"mathOperator\", function (parser, runtime, tokens) {\n\t\tvar expr = parser.parseElement(\"unaryExpression\", tokens);\n\t\tvar mathOp,\n\t\t\tinitialMathOp = null;\n\t\tmathOp = tokens.matchAnyOpToken(\"+\", \"-\", \"*\", \"/\", \"%\");\n\t\twhile (mathOp) {\n\t\t\tinitialMathOp = initialMathOp || mathOp;\n\t\t\tvar operator = mathOp.value;\n\t\t\tif (initialMathOp.value !== operator) {\n\t\t\t\tparser.raiseParseError(tokens, \"You must parenthesize math operations with different operators\");\n\t\t\t}\n\t\t\tvar rhs = parser.parseElement(\"unaryExpression\", tokens);\n\t\t\texpr = {\n\t\t\t\ttype: \"mathOperator\",\n\t\t\t\tlhs: expr,\n\t\t\t\trhs: rhs,\n\t\t\t\toperator: operator,\n\t\t\t\targs: [expr, rhs],\n\t\t\t\top: function (context, lhsVal, rhsVal) {\n\t\t\t\t\tif (operator === \"+\") {\n\t\t\t\t\t\treturn lhsVal + rhsVal;\n\t\t\t\t\t} else if (operator === \"-\") {\n\t\t\t\t\t\treturn lhsVal - rhsVal;\n\t\t\t\t\t} else if (operator === \"*\") {\n\t\t\t\t\t\treturn lhsVal * rhsVal;\n\t\t\t\t\t} else if (operator === \"/\") {\n\t\t\t\t\t\treturn lhsVal / rhsVal;\n\t\t\t\t\t} else if (operator === \"%\") {\n\t\t\t\t\t\treturn lhsVal % rhsVal;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t\tmathOp = tokens.matchAnyOpToken(\"+\", \"-\", \"*\", \"/\", \"%\");\n\t\t}\n\t\treturn expr;\n\t});\n\n\t_parser.addGrammarElement(\"mathExpression\", function (parser, runtime, tokens) {\n\t\treturn parser.parseAnyOf([\"mathOperator\", \"unaryExpression\"], tokens);\n\t});\n\n\tfunction sloppyContains(src, container, value){\n\t\tif (container['contains']) {\n\t\t\treturn container.contains(value);\n\t\t} else if (container['includes']) {\n\t\t\treturn container.includes(value);\n\t\t} else {\n\t\t\tthrow Error(\"The value of \" + src.sourceFor() + \" does not have a contains or includes method on it\");\n\t\t}\n\t}\n\tfunction sloppyMatches(src, target, toMatch){\n\t\tif (target['match']) {\n\t\t\treturn !!target.match(toMatch);\n\t\t} else if (target['matches']) {\n\t\t\treturn target.matches(toMatch);\n\t\t} else {\n\t\t\tthrow Error(\"The value of \" + src.sourceFor() + \" does not have a match or matches method on it\");\n\t\t}\n\t}\n\n\t_parser.addGrammarElement(\"comparisonOperator\", function (parser, runtime, tokens) {\n\t\tvar expr = parser.parseElement(\"mathExpression\", tokens);\n\t\tvar comparisonToken = tokens.matchAnyOpToken(\"<\", \">\", \"<=\", \">=\", \"==\", \"===\", \"!=\", \"!==\");\n\t\tvar operator = comparisonToken ? comparisonToken.value : null;\n\t\tvar hasRightValue = true; // By default, most comparisons require two values, but there are some exceptions.\n\t\tvar typeCheck = false;\n\n\t\tif (operator == null) {\n\t\t\tif (tokens.matchToken(\"is\") || tokens.matchToken(\"am\")) {\n\t\t\t\tif (tokens.matchToken(\"not\")) {\n\t\t\t\t\tif (tokens.matchToken(\"in\")) {\n\t\t\t\t\t\toperator = \"not in\";\n\t\t\t\t\t} else if (tokens.matchToken(\"a\")) {\n\t\t\t\t\t\toperator = \"not a\";\n\t\t\t\t\t\ttypeCheck = true;\n\t\t\t\t\t} else if (tokens.matchToken(\"empty\")) {\n\t\t\t\t\t\toperator = \"not empty\";\n\t\t\t\t\t\thasRightValue = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\toperator = \"!=\";\n\t\t\t\t\t}\n\t\t\t\t} else if (tokens.matchToken(\"in\")) {\n\t\t\t\t\toperator = \"in\";\n\t\t\t\t} else if (tokens.matchToken(\"a\")) {\n\t\t\t\t\toperator = \"a\";\n\t\t\t\t\ttypeCheck = true;\n\t\t\t\t} else if (tokens.matchToken(\"empty\")) {\n\t\t\t\t\toperator = \"empty\";\n\t\t\t\t\thasRightValue = false;\n\t\t\t\t} else if (tokens.matchToken(\"less\")) {\n\t\t\t\t\ttokens.requireToken(\"than\");\n\t\t\t\t\tif (tokens.matchToken(\"or\")) {\n\t\t\t\t\t\ttokens.requireToken(\"equal\");\n\t\t\t\t\t\ttokens.requireToken(\"to\");\n\t\t\t\t\t\toperator = \"<=\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\toperator = \"<\";\n\t\t\t\t\t}\n\t\t\t\t} else if (tokens.matchToken(\"greater\")) {\n\t\t\t\t\ttokens.requireToken(\"than\");\n\t\t\t\t\tif (tokens.matchToken(\"or\")) {\n\t\t\t\t\t\ttokens.requireToken(\"equal\");\n\t\t\t\t\t\ttokens.requireToken(\"to\");\n\t\t\t\t\t\toperator = \">=\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\toperator = \">\";\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\toperator = \"==\";\n\t\t\t\t}\n\t\t\t} else if (tokens.matchToken(\"exist\") || tokens.matchToken(\"exists\")) {\n\t\t\t\toperator = \"exist\";\n\t\t\t\thasRightValue = false;\n\t\t\t} else if (tokens.matchToken(\"matches\") || tokens.matchToken(\"match\")) {\n\t\t\t\toperator = \"match\";\n\t\t\t} else if (tokens.matchToken(\"contains\") || tokens.matchToken(\"contain\")) {\n\t\t\t\toperator = \"contain\";\n\t\t\t} else if (tokens.matchToken(\"includes\") || tokens.matchToken(\"include\")) {\n\t\t\t\toperator = \"include\";\n\t\t\t} else if (tokens.matchToken(\"do\") || tokens.matchToken(\"does\")) {\n\t\t\t\ttokens.requireToken(\"not\");\n\t\t\t\tif (tokens.matchToken(\"matches\") || tokens.matchToken(\"match\")) {\n\t\t\t\t\toperator = \"not match\";\n\t\t\t\t} else if (tokens.matchToken(\"contains\") || tokens.matchToken(\"contain\")) {\n\t\t\t\t\toperator = \"not contain\";\n\t\t\t\t} else if (tokens.matchToken(\"exist\") || tokens.matchToken(\"exist\")) {\n\t\t\t\t\toperator = \"not exist\";\n\t\t\t\t\thasRightValue = false;\n\t\t\t\t} else if (tokens.matchToken(\"include\")) {\n\t\t\t\t\toperator = \"not include\";\n\t\t\t\t} else {\n\t\t\t\t\tparser.raiseParseError(tokens, \"Expected matches or contains\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (operator) {\n\t\t\t// Do not allow chained comparisons, which is dumb\n\t\t\tif (typeCheck) {\n\t\t\t\tvar typeName = tokens.requireTokenType(\"IDENTIFIER\");\n\t\t\t\tvar nullOk = !tokens.matchOpToken(\"!\");\n\t\t\t} else if (hasRightValue) {\n\t\t\t\tvar rhs = parser.requireElement(\"mathExpression\", tokens);\n\t\t\t\tif (operator === \"match\" || operator === \"not match\") {\n\t\t\t\t\trhs = rhs.css ? rhs.css : rhs;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar lhs = expr;\n\t\t\texpr = {\n\t\t\t\ttype: \"comparisonOperator\",\n\t\t\t\toperator: operator,\n\t\t\t\ttypeName: typeName,\n\t\t\t\tnullOk: nullOk,\n\t\t\t\tlhs: expr,\n\t\t\t\trhs: rhs,\n\t\t\t\targs: [expr, rhs],\n\t\t\t\top: function (context, lhsVal, rhsVal) {\n\t\t\t\t\tif (operator === \"==\") {\n\t\t\t\t\t\treturn lhsVal == rhsVal;\n\t\t\t\t\t} else if (operator === \"!=\") {\n\t\t\t\t\t\treturn lhsVal != rhsVal;\n\t\t\t\t\t}\n\t\t\t\t\tif (operator === \"match\") {\n\t\t\t\t\t\treturn lhsVal != null && sloppyMatches(lhs, lhsVal, rhsVal);\n\t\t\t\t\t}\n\t\t\t\t\tif (operator === \"not match\") {\n\t\t\t\t\t\treturn lhsVal == null || !sloppyMatches(lhs, lhsVal, rhsVal);\n\t\t\t\t\t}\n\t\t\t\t\tif (operator === \"in\") {\n\t\t\t\t\t\treturn rhsVal != null && sloppyContains(rhs, rhsVal, lhsVal);\n\t\t\t\t\t}\n\t\t\t\t\tif (operator === \"not in\") {\n\t\t\t\t\t\treturn rhsVal == null || !sloppyContains(rhs, rhsVal, lhsVal);\n\t\t\t\t\t}\n\t\t\t\t\tif (operator === \"contain\") {\n\t\t\t\t\t\treturn lhsVal != null && sloppyContains(lhs, lhsVal, rhsVal);\n\t\t\t\t\t}\n\t\t\t\t\tif (operator === \"not contain\") {\n\t\t\t\t\t\treturn lhsVal == null || !sloppyContains(lhs, lhsVal, rhsVal);\n\t\t\t\t\t}\n\t\t\t\t\tif (operator === \"include\") {\n\t\t\t\t\t\treturn lhsVal != null && sloppyContains(lhs, lhsVal, rhsVal);\n\t\t\t\t\t}\n\t\t\t\t\tif (operator === \"not include\") {\n\t\t\t\t\t\treturn lhsVal == null || !sloppyContains(lhs, lhsVal, rhsVal);\n\t\t\t\t\t}\n\t\t\t\t\tif (operator === \"===\") {\n\t\t\t\t\t\treturn lhsVal === rhsVal;\n\t\t\t\t\t} else if (operator === \"!==\") {\n\t\t\t\t\t\treturn lhsVal !== rhsVal;\n\t\t\t\t\t} else if (operator === \"<\") {\n\t\t\t\t\t\treturn lhsVal < rhsVal;\n\t\t\t\t\t} else if (operator === \">\") {\n\t\t\t\t\t\treturn lhsVal > rhsVal;\n\t\t\t\t\t} else if (operator === \"<=\") {\n\t\t\t\t\t\treturn lhsVal <= rhsVal;\n\t\t\t\t\t} else if (operator === \">=\") {\n\t\t\t\t\t\treturn lhsVal >= rhsVal;\n\t\t\t\t\t} else if (operator === \"empty\") {\n\t\t\t\t\t\treturn runtime.isEmpty(lhsVal);\n\t\t\t\t\t} else if (operator === \"not empty\") {\n\t\t\t\t\t\treturn !runtime.isEmpty(lhsVal);\n\t\t\t\t\t} else if (operator === \"exist\") {\n\t\t\t\t\t\treturn runtime.doesExist(lhsVal);\n\t\t\t\t\t} else if (operator === \"not exist\") {\n\t\t\t\t\t\treturn !runtime.doesExist(lhsVal);\n\t\t\t\t\t} else if (operator === \"a\") {\n\t\t\t\t\t\treturn runtime.typeCheck(lhsVal, typeName.value, nullOk);\n\t\t\t\t\t} else if (operator === \"not a\") {\n\t\t\t\t\t\treturn !runtime.typeCheck(lhsVal, typeName.value, nullOk);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow \"Unknown comparison : \" + operator;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t\treturn expr;\n\t});\n\n\t_parser.addGrammarElement(\"comparisonExpression\", function (parser, runtime, tokens) {\n\t\treturn parser.parseAnyOf([\"comparisonOperator\", \"mathExpression\"], tokens);\n\t});\n\n\t_parser.addGrammarElement(\"logicalOperator\", function (parser, runtime, tokens) {\n\t\tvar expr = parser.parseElement(\"comparisonExpression\", tokens);\n\t\tvar logicalOp,\n\t\t\tinitialLogicalOp = null;\n\t\tlogicalOp = tokens.matchToken(\"and\") || tokens.matchToken(\"or\");\n\t\twhile (logicalOp) {\n\t\t\tinitialLogicalOp = initialLogicalOp || logicalOp;\n\t\t\tif (initialLogicalOp.value !== logicalOp.value) {\n\t\t\t\tparser.raiseParseError(tokens, \"You must parenthesize logical operations with different operators\");\n\t\t\t}\n\t\t\tvar rhs = parser.requireElement(\"comparisonExpression\", tokens);\n\t\t\tconst operator = logicalOp.value;\n\t\t\texpr = {\n\t\t\t\ttype: \"logicalOperator\",\n\t\t\t\toperator: operator,\n\t\t\t\tlhs: expr,\n\t\t\t\trhs: rhs,\n\t\t\t\targs: [expr, rhs],\n\t\t\t\top: function (context, lhsVal, rhsVal) {\n\t\t\t\t\tif (operator === \"and\") {\n\t\t\t\t\t\treturn lhsVal && rhsVal;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn lhsVal || rhsVal;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t\tlogicalOp = tokens.matchToken(\"and\") || tokens.matchToken(\"or\");\n\t\t}\n\t\treturn expr;\n\t});\n\n\t_parser.addGrammarElement(\"logicalExpression\", function (parser, runtime, tokens) {\n\t\treturn parser.parseAnyOf([\"logicalOperator\", \"mathExpression\"], tokens);\n\t});\n\n\t_parser.addGrammarElement(\"asyncExpression\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"async\")) {\n\t\t\tvar value = parser.requireElement(\"logicalExpression\", tokens);\n\t\t\tvar expr = {\n\t\t\t\ttype: \"asyncExpression\",\n\t\t\t\tvalue: value,\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tasyncWrapper: true,\n\t\t\t\t\t\tvalue: this.value.evaluate(context), //OK\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t};\n\t\t\treturn expr;\n\t\t} else {\n\t\t\treturn parser.parseElement(\"logicalExpression\", tokens);\n\t\t}\n\t});\n\n\t_parser.addGrammarElement(\"expression\", function (parser, runtime, tokens) {\n\t\ttokens.matchToken(\"the\"); // optional the\n\t\treturn parser.parseElement(\"asyncExpression\", tokens);\n\t});\n\n\t_parser.addGrammarElement(\"assignableExpression\", function (parser, runtime, tokens) {\n\t\ttokens.matchToken(\"the\"); // optional the\n\n\t\t// TODO obviously we need to generalize this as a left hand side / targetable concept\n\t\tvar expr = parser.parseElement(\"primaryExpression\", tokens);\n\t\tif (expr && (\n\t\t\texpr.type === \"symbol\" ||\n\t\t\texpr.type === \"ofExpression\" ||\n\t\t\texpr.type === \"propertyAccess\" ||\n\t\t\texpr.type === \"attributeRefAccess\" ||\n\t\t\texpr.type === \"attributeRef\" ||\n\t\t\texpr.type === \"styleRef\" ||\n\t\t\texpr.type === \"arrayIndex\" ||\n\t\t\texpr.type === \"possessive\")\n\t\t) {\n\t\t\treturn expr;\n\t\t} else {\n\t\t\t_parser.raiseParseError(\n\t\t\t\ttokens,\n\t\t\t\t\"A target expression must be writable.  The expression type '\" + (expr && expr.type) + \"' is not.\"\n\t\t\t);\n\t\t}\n\t\treturn expr;\n\t});\n\n\t_parser.addGrammarElement(\"hyperscript\", function (parser, runtime, tokens) {\n\t\tvar features = [];\n\n\t\tif (tokens.hasMore()) {\n\t\t\twhile (parser.featureStart(tokens.currentToken()) || tokens.currentToken().value === \"(\") {\n\t\t\t\tvar feature = parser.requireElement(\"feature\", tokens);\n\t\t\t\tfeatures.push(feature);\n\t\t\t\ttokens.matchToken(\"end\"); // optional end\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\ttype: \"hyperscript\",\n\t\t\tfeatures: features,\n\t\t\tapply: function (target, source, args) {\n\t\t\t\t// no op\n\t\t\t\tfor (const feature of features) {\n\t\t\t\t\tfeature.install(target, source, args);\n\t\t\t\t}\n\t\t\t},\n\t\t};\n\t});\n\n\tvar parseEventArgs = function (tokens) {\n\t\tvar args = [];\n\t\t// handle argument list (look ahead 3)\n\t\tif (\n\t\t\ttokens.token(0).value === \"(\" &&\n\t\t\t(tokens.token(1).value === \")\" || tokens.token(2).value === \",\" || tokens.token(2).value === \")\")\n\t\t) {\n\t\t\ttokens.matchOpToken(\"(\");\n\t\t\tdo {\n\t\t\t\targs.push(tokens.requireTokenType(\"IDENTIFIER\"));\n\t\t\t} while (tokens.matchOpToken(\",\"));\n\t\t\ttokens.requireOpToken(\")\");\n\t\t}\n\t\treturn args;\n\t};\n\n\t_parser.addFeature(\"on\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"on\")) return;\n\t\tvar every = false;\n\t\tif (tokens.matchToken(\"every\")) {\n\t\t\tevery = true;\n\t\t}\n\t\tvar events = [];\n\t\tvar displayName = null;\n\t\tdo {\n\t\t\tvar on = parser.requireElement(\"eventName\", tokens, \"Expected event name\");\n\n\t\t\tvar eventName = on.evaluate(); // OK No Promise\n\n\t\t\tif (displayName) {\n\t\t\t\tdisplayName = displayName + \" or \" + eventName;\n\t\t\t} else {\n\t\t\t\tdisplayName = \"on \" + eventName;\n\t\t\t}\n\t\t\tvar args = parseEventArgs(tokens);\n\n\t\t\tvar filter = null;\n\t\t\tif (tokens.matchOpToken(\"[\")) {\n\t\t\t\tfilter = parser.requireElement(\"expression\", tokens);\n\t\t\t\ttokens.requireOpToken(\"]\");\n\t\t\t}\n\n\t\t\tif (tokens.currentToken().type === \"NUMBER\") {\n\t\t\t\tvar startCountToken = tokens.consumeToken();\n\t\t\t\tvar startCount = parseInt(startCountToken.value);\n\t\t\t\tif (tokens.matchToken(\"to\")) {\n\t\t\t\t\tvar endCountToken = tokens.consumeToken();\n\t\t\t\t\tvar endCount = parseInt(endCountToken.value);\n\t\t\t\t} else if (tokens.matchToken(\"and\")) {\n\t\t\t\t\tvar unbounded = true;\n\t\t\t\t\ttokens.requireToken(\"on\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (eventName === \"intersection\") {\n\t\t\t\tvar intersectionSpec = {};\n\t\t\t\tif (tokens.matchToken(\"with\")) {\n\t\t\t\t\tintersectionSpec[\"with\"] = parser.requireElement(\"expression\", tokens).evaluate();\n\t\t\t\t}\n\t\t\t\tif (tokens.matchToken(\"having\")) {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (tokens.matchToken(\"margin\")) {\n\t\t\t\t\t\t\tintersectionSpec[\"rootMargin\"] = parser.requireElement(\"stringLike\", tokens).evaluate();\n\t\t\t\t\t\t} else if (tokens.matchToken(\"threshold\")) {\n\t\t\t\t\t\t\tintersectionSpec[\"threshold\"] = parser.requireElement(\"expression\", tokens).evaluate();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tparser.raiseParseError(tokens, \"Unknown intersection config specification\");\n\t\t\t\t\t\t}\n\t\t\t\t\t} while (tokens.matchToken(\"and\"));\n\t\t\t\t}\n\t\t\t} else if (eventName === \"mutation\") {\n\t\t\t\tvar mutationSpec = {};\n\t\t\t\tif (tokens.matchToken(\"of\")) {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (tokens.matchToken(\"anything\")) {\n\t\t\t\t\t\t\tmutationSpec[\"attributes\"] = true;\n\t\t\t\t\t\t\tmutationSpec[\"subtree\"] = true;\n\t\t\t\t\t\t\tmutationSpec[\"characterData\"] = true;\n\t\t\t\t\t\t\tmutationSpec[\"childList\"] = true;\n\t\t\t\t\t\t} else if (tokens.matchToken(\"childList\")) {\n\t\t\t\t\t\t\tmutationSpec[\"childList\"] = true;\n\t\t\t\t\t\t} else if (tokens.matchToken(\"attributes\")) {\n\t\t\t\t\t\t\tmutationSpec[\"attributes\"] = true;\n\t\t\t\t\t\t\tmutationSpec[\"attributeOldValue\"] = true;\n\t\t\t\t\t\t} else if (tokens.matchToken(\"subtree\")) {\n\t\t\t\t\t\t\tmutationSpec[\"subtree\"] = true;\n\t\t\t\t\t\t} else if (tokens.matchToken(\"characterData\")) {\n\t\t\t\t\t\t\tmutationSpec[\"characterData\"] = true;\n\t\t\t\t\t\t\tmutationSpec[\"characterDataOldValue\"] = true;\n\t\t\t\t\t\t} else if (tokens.currentToken().type === \"ATTRIBUTE_REF\") {\n\t\t\t\t\t\t\tvar attribute = tokens.consumeToken();\n\t\t\t\t\t\t\tif (mutationSpec[\"attributeFilter\"] == null) {\n\t\t\t\t\t\t\t\tmutationSpec[\"attributeFilter\"] = [];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (attribute.value.indexOf(\"@\") == 0) {\n\t\t\t\t\t\t\t\tmutationSpec[\"attributeFilter\"].push(attribute.value.substring(1));\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tparser.raiseParseError(\n\t\t\t\t\t\t\t\t\ttokens,\n\t\t\t\t\t\t\t\t\t\"Only shorthand attribute references are allowed here\"\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tparser.raiseParseError(tokens, \"Unknown mutation config specification\");\n\t\t\t\t\t\t}\n\t\t\t\t\t} while (tokens.matchToken(\"or\"));\n\t\t\t\t} else {\n\t\t\t\t\tmutationSpec[\"attributes\"] = true;\n\t\t\t\t\tmutationSpec[\"characterData\"] = true;\n\t\t\t\t\tmutationSpec[\"childList\"] = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar from = null;\n\t\t\tvar elsewhere = false;\n\t\t\tif (tokens.matchToken(\"from\")) {\n\t\t\t\tif (tokens.matchToken(\"elsewhere\")) {\n\t\t\t\t\telsewhere = true;\n\t\t\t\t} else {\n\t\t\t\t\tfrom = parser.parseElement(\"expression\", tokens);\n\t\t\t\t\tif (!from) {\n\t\t\t\t\t\tparser.raiseParseError(tokens, 'Expected either target value or \"elsewhere\".');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// support both \"elsewhere\" and \"from elsewhere\"\n\t\t\tif (from === null && elsewhere === false && tokens.matchToken(\"elsewhere\")) {\n\t\t\t\telsewhere = true;\n\t\t\t}\n\n\t\t\tif (tokens.matchToken(\"in\")) {\n\t\t\t\tvar inExpr = parser.parseElement('unaryExpression', tokens);\n\t\t\t}\n\n\t\t\tif (tokens.matchToken(\"debounced\")) {\n\t\t\t\ttokens.requireToken(\"at\");\n\t\t\t\tvar timeExpr = parser.requireElement(\"expression\", tokens);\n\t\t\t\t// @ts-ignore\n\t\t\t\tvar debounceTime = timeExpr.evaluate({}); // OK No promise TODO make a literal time expr\n\t\t\t} else if (tokens.matchToken(\"throttled\")) {\n\t\t\t\ttokens.requireToken(\"at\");\n\t\t\t\tvar timeExpr = parser.requireElement(\"expression\", tokens);\n\t\t\t\t// @ts-ignore\n\t\t\t\tvar throttleTime = timeExpr.evaluate({}); // OK No promise TODO make a literal time expr\n\t\t\t}\n\n\t\t\tevents.push({\n\t\t\t\texecCount: 0,\n\t\t\t\tevery: every,\n\t\t\t\ton: eventName,\n\t\t\t\targs: args,\n\t\t\t\tfilter: filter,\n\t\t\t\tfrom: from,\n\t\t\t\tinExpr: inExpr,\n\t\t\t\telsewhere: elsewhere,\n\t\t\t\tstartCount: startCount,\n\t\t\t\tendCount: endCount,\n\t\t\t\tunbounded: unbounded,\n\t\t\t\tdebounceTime: debounceTime,\n\t\t\t\tthrottleTime: throttleTime,\n\t\t\t\tmutationSpec: mutationSpec,\n\t\t\t\tintersectionSpec: intersectionSpec,\n\t\t\t\tdebounced: undefined,\n\t\t\t\tlastExec: undefined,\n\t\t\t});\n\t\t} while (tokens.matchToken(\"or\"));\n\n\t\tvar queueLast = true;\n\t\tif (!every) {\n\t\t\tif (tokens.matchToken(\"queue\")) {\n\t\t\t\tif (tokens.matchToken(\"all\")) {\n\t\t\t\t\tvar queueAll = true;\n\t\t\t\t\tvar queueLast = false;\n\t\t\t\t} else if (tokens.matchToken(\"first\")) {\n\t\t\t\t\tvar queueFirst = true;\n\t\t\t\t} else if (tokens.matchToken(\"none\")) {\n\t\t\t\t\tvar queueNone = true;\n\t\t\t\t} else {\n\t\t\t\t\ttokens.requireToken(\"last\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar start = parser.requireElement(\"commandList\", tokens);\n\t\tparser.ensureTerminated(start);\n\n\t\tif (tokens.matchToken(\"catch\")) {\n\t\t\tvar errorSymbol = tokens.requireTokenType(\"IDENTIFIER\").value;\n\t\t\tvar errorHandler = parser.requireElement(\"commandList\", tokens);\n\t\t\tparser.ensureTerminated(errorHandler);\n\t\t}\n\n\t\tif (tokens.matchToken(\"finally\")) {\n\t\t\tvar finallyHandler = parser.requireElement(\"commandList\", tokens);\n\t\t\tparser.ensureTerminated(finallyHandler);\n\t\t}\n\n\t\tvar onFeature = {\n\t\t\tdisplayName: displayName,\n\t\t\tevents: events,\n\t\t\tstart: start,\n\t\t\tevery: every,\n\t\t\texecCount: 0,\n\t\t\terrorHandler: errorHandler,\n\t\t\terrorSymbol: errorSymbol,\n\t\t\texecute: function (/** @type {Context} */ ctx) {\n\t\t\t\tlet eventQueueInfo = runtime.getEventQueueFor(ctx.me, onFeature);\n\t\t\t\tif (eventQueueInfo.executing && every === false) {\n\t\t\t\t\tif (queueNone || (queueFirst && eventQueueInfo.queue.length > 0)) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (queueLast) {\n\t\t\t\t\t\teventQueueInfo.queue.length = 0;\n\t\t\t\t\t}\n\t\t\t\t\teventQueueInfo.queue.push(ctx);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tonFeature.execCount++;\n\t\t\t\teventQueueInfo.executing = true;\n\t\t\t\tctx.meta.onHalt = function () {\n\t\t\t\t\teventQueueInfo.executing = false;\n\t\t\t\t\tvar queued = eventQueueInfo.queue.shift();\n\t\t\t\t\tif (queued) {\n\t\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\t\tonFeature.execute(queued);\n\t\t\t\t\t\t}, 1);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tctx.meta.reject = function (err) {\n\t\t\t\t\tconsole.error(err.message ? err.message : err);\n\t\t\t\t\tvar hypertrace = runtime.getHyperTrace(ctx, err);\n\t\t\t\t\tif (hypertrace) {\n\t\t\t\t\t\thypertrace.print();\n\t\t\t\t\t}\n\t\t\t\t\truntime.triggerEvent(ctx.me, \"exception\", {\n\t\t\t\t\t\terror: err,\n\t\t\t\t\t});\n\t\t\t\t};\n\t\t\t\tstart.execute(ctx);\n\t\t\t},\n\t\t\tinstall: function (elt, source) {\n\t\t\t\tfor (const eventSpec of onFeature.events) {\n\t\t\t\t\tvar targets;\n\t\t\t\t\tif (eventSpec.elsewhere) {\n\t\t\t\t\t\ttargets = [document];\n\t\t\t\t\t} else if (eventSpec.from) {\n\t\t\t\t\t\ttargets = eventSpec.from.evaluate(runtime.makeContext(elt, onFeature, elt, null));\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttargets = [elt];\n\t\t\t\t\t}\n\t\t\t\t\truntime.implicitLoop(targets, function (target) {\n\t\t\t\t\t\t// OK NO PROMISE\n\n\t\t\t\t\t\tvar eventName = eventSpec.on;\n\t\t\t\t\t\tif (eventSpec.mutationSpec) {\n\t\t\t\t\t\t\teventName = \"hyperscript:mutation\";\n\t\t\t\t\t\t\tconst observer = new MutationObserver(function (mutationList, observer) {\n\t\t\t\t\t\t\t\tif (!onFeature.executing) {\n\t\t\t\t\t\t\t\t\t_runtime.triggerEvent(target, eventName, {\n\t\t\t\t\t\t\t\t\t\tmutationList: mutationList,\n\t\t\t\t\t\t\t\t\t\tobserver: observer,\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tobserver.observe(target, eventSpec.mutationSpec);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (eventSpec.intersectionSpec) {\n\t\t\t\t\t\t\teventName = \"hyperscript:insersection\";\n\t\t\t\t\t\t\tconst observer = new IntersectionObserver(function (entries) {\n\t\t\t\t\t\t\t\tfor (const entry of entries) {\n\t\t\t\t\t\t\t\t\tvar detail = {\n\t\t\t\t\t\t\t\t\t\tobserver: observer,\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\tdetail = mergeObjects(detail, entry);\n\t\t\t\t\t\t\t\t\tdetail[\"intersecting\"] = entry.isIntersecting;\n\t\t\t\t\t\t\t\t\t_runtime.triggerEvent(target, eventName, detail);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}, eventSpec.intersectionSpec);\n\t\t\t\t\t\t\tobserver.observe(target);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar addEventListener = target.addEventListener || target.on;\n\t\t\t\t\t\taddEventListener.call(target, eventName, function listener(evt) {\n\t\t\t\t\t\t\t// OK NO PROMISE\n\t\t\t\t\t\t\tif (typeof Node !== 'undefined' && elt instanceof Node && target !== elt && !elt.isConnected) {\n\t\t\t\t\t\t\t\ttarget.removeEventListener(eventName, listener);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvar ctx = runtime.makeContext(elt, onFeature, elt, evt);\n\t\t\t\t\t\t\tif (eventSpec.elsewhere && elt.contains(evt.target)) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (eventSpec.from) {\n\t\t\t\t\t\t\t\tctx.result = target;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// establish context\n\t\t\t\t\t\t\tfor (const arg of eventSpec.args) {\n\t\t\t\t\t\t\t\tlet eventValue = ctx.event[arg.value];\n\t\t\t\t\t\t\t\tif (eventValue !== undefined) {\n\t\t\t\t\t\t\t\t\tctx[arg.value] = eventValue;\n\t\t\t\t\t\t\t\t} else if ('detail' in ctx.event) {\n\t\t\t\t\t\t\t\t\tctx[arg.value] = ctx.event['detail'][arg.value];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// install error handler if any\n\t\t\t\t\t\t\tctx.meta.errorHandler = errorHandler;\n\t\t\t\t\t\t\tctx.meta.errorSymbol = errorSymbol;\n\t\t\t\t\t\t\tctx.meta.finallyHandler = finallyHandler;\n\n\t\t\t\t\t\t\t// apply filter\n\t\t\t\t\t\t\tif (eventSpec.filter) {\n\t\t\t\t\t\t\t\tvar initialCtx = ctx.meta.context;\n\t\t\t\t\t\t\t\tctx.meta.context = ctx.event;\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tvar value = eventSpec.filter.evaluate(ctx); //OK NO PROMISE\n\t\t\t\t\t\t\t\t\tif (value) {\n\t\t\t\t\t\t\t\t\t\t// match the javascript semantics for if statements\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\t\tctx.meta.context = initialCtx;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (eventSpec.inExpr) {\n\t\t\t\t\t\t\t\tvar inElement = evt.target;\n\t\t\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\t\t\tif (inElement.matches && inElement.matches(eventSpec.inExpr.css)) {\n\t\t\t\t\t\t\t\t\t\tctx.result = inElement;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tinElement = inElement.parentElement;\n\t\t\t\t\t\t\t\t\t\tif (inElement == null) {\n\t\t\t\t\t\t\t\t\t\t\treturn; // no match found\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// verify counts\n\t\t\t\t\t\t\teventSpec.execCount++;\n\t\t\t\t\t\t\tif (eventSpec.startCount) {\n\t\t\t\t\t\t\t\tif (eventSpec.endCount) {\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\teventSpec.execCount < eventSpec.startCount ||\n\t\t\t\t\t\t\t\t\t\teventSpec.execCount > eventSpec.endCount\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (eventSpec.unbounded) {\n\t\t\t\t\t\t\t\t\tif (eventSpec.execCount < eventSpec.startCount) {\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (eventSpec.execCount !== eventSpec.startCount) {\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t//debounce\n\t\t\t\t\t\t\tif (eventSpec.debounceTime) {\n\t\t\t\t\t\t\t\tif (eventSpec.debounced) {\n\t\t\t\t\t\t\t\t\tclearTimeout(eventSpec.debounced);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\teventSpec.debounced = setTimeout(function () {\n\t\t\t\t\t\t\t\t\tonFeature.execute(ctx);\n\t\t\t\t\t\t\t\t}, eventSpec.debounceTime);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// throttle\n\t\t\t\t\t\t\tif (eventSpec.throttleTime) {\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\teventSpec.lastExec &&\n\t\t\t\t\t\t\t\t\tDate.now() < eventSpec.lastExec + eventSpec.throttleTime\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\teventSpec.lastExec = Date.now();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// apply execute\n\t\t\t\t\t\t\tonFeature.execute(ctx);\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t},\n\t\t};\n\t\tparser.setParent(start, onFeature);\n\t\treturn onFeature;\n\t});\n\n\t_parser.addFeature(\"def\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"def\")) return;\n\t\tvar functionName = parser.requireElement(\"dotOrColonPath\", tokens);\n\t\tvar nameVal = functionName.evaluate(); // OK\n\t\tvar nameSpace = nameVal.split(\".\");\n\t\tvar funcName = nameSpace.pop();\n\n\t\tvar args = [];\n\t\tif (tokens.matchOpToken(\"(\")) {\n\t\t\tif (tokens.matchOpToken(\")\")) {\n\t\t\t\t// emtpy args list\n\t\t\t} else {\n\t\t\t\tdo {\n\t\t\t\t\targs.push(tokens.requireTokenType(\"IDENTIFIER\"));\n\t\t\t\t} while (tokens.matchOpToken(\",\"));\n\t\t\t\ttokens.requireOpToken(\")\");\n\t\t\t}\n\t\t}\n\n\t\tvar start = parser.requireElement(\"commandList\", tokens);\n\n\t\tif (tokens.matchToken(\"catch\")) {\n\t\t\tvar errorSymbol = tokens.requireTokenType(\"IDENTIFIER\").value;\n\t\t\tvar errorHandler = parser.parseElement(\"commandList\", tokens);\n\t\t}\n\n\t\tif (tokens.matchToken(\"finally\")) {\n\t\t\tvar finallyHandler = parser.requireElement(\"commandList\", tokens);\n\t\t\tparser.ensureTerminated(finallyHandler);\n\t\t}\n\n\t\tvar functionFeature = {\n\t\t\tdisplayName:\n\t\t\t\tfuncName +\n\t\t\t\t\"(\" +\n\t\t\t\targs\n\t\t\t\t\t.map(function (arg) {\n\t\t\t\t\t\treturn arg.value;\n\t\t\t\t\t})\n\t\t\t\t\t.join(\", \") +\n\t\t\t\t\")\",\n\t\t\tname: funcName,\n\t\t\targs: args,\n\t\t\tstart: start,\n\t\t\terrorHandler: errorHandler,\n\t\t\terrorSymbol: errorSymbol,\n\t\t\tfinallyHandler: finallyHandler,\n\t\t\tinstall: function (target, source) {\n\t\t\t\tvar func = function () {\n\t\t\t\t\t// null, worker\n\t\t\t\t\tvar ctx = runtime.makeContext(source, functionFeature, target, null);\n\n\t\t\t\t\t// install error handler if any\n\t\t\t\t\tctx.meta.errorHandler = errorHandler;\n\t\t\t\t\tctx.meta.errorSymbol = errorSymbol;\n\t\t\t\t\tctx.meta.finallyHandler = finallyHandler;\n\n\t\t\t\t\tfor (var i = 0; i < args.length; i++) {\n\t\t\t\t\t\tvar name = args[i];\n\t\t\t\t\t\tvar argumentVal = arguments[i];\n\t\t\t\t\t\tif (name) {\n\t\t\t\t\t\t\tctx[name.value] = argumentVal;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tctx.meta.caller = arguments[args.length];\n\t\t\t\t\tif (ctx.meta.caller) {\n\t\t\t\t\t\tctx.meta.callingCommand = ctx.meta.caller.meta.command;\n\t\t\t\t\t}\n\t\t\t\t\tvar resolve,\n\t\t\t\t\t\treject = null;\n\t\t\t\t\tvar promise = new Promise(function (theResolve, theReject) {\n\t\t\t\t\t\tresolve = theResolve;\n\t\t\t\t\t\treject = theReject;\n\t\t\t\t\t});\n\t\t\t\t\tstart.execute(ctx);\n\t\t\t\t\tif (ctx.meta.returned) {\n\t\t\t\t\t\treturn ctx.meta.returnValue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tctx.meta.resolve = resolve;\n\t\t\t\t\t\tctx.meta.reject = reject;\n\t\t\t\t\t\treturn promise;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tfunc.hyperfunc = true;\n\t\t\t\tfunc.hypername = nameVal;\n\t\t\t\truntime.assignToNamespace(target, nameSpace, funcName, func);\n\t\t\t},\n\t\t};\n\n\t\tparser.ensureTerminated(start);\n\n\t\t// terminate error handler if any\n\t\tif (errorHandler) {\n\t\t\tparser.ensureTerminated(errorHandler);\n\t\t}\n\n\t\tparser.setParent(start, functionFeature);\n\t\treturn functionFeature;\n\t});\n\n\t_parser.addFeature(\"set\", function (parser, runtime, tokens) {\n\t\tlet setCmd = parser.parseElement(\"setCommand\", tokens);\n\t\tif (setCmd) {\n\t\t\tif (setCmd.target.scope !== \"element\") {\n\t\t\t\tparser.raiseParseError(tokens, \"variables declared at the feature level must be element scoped.\");\n\t\t\t}\n\t\t\tlet setFeature = {\n\t\t\t\tstart: setCmd,\n\t\t\t\tinstall: function (target, source) {\n\t\t\t\t\tsetCmd && setCmd.execute(runtime.makeContext(target, setFeature, target, null));\n\t\t\t\t},\n\t\t\t};\n\t\t\tparser.ensureTerminated(setCmd);\n\t\t\treturn setFeature;\n\t\t}\n\t});\n\n\t_parser.addFeature(\"init\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"init\")) return;\n\n\t\tvar start = parser.requireElement(\"commandList\", tokens);\n\t\tvar initFeature = {\n\t\t\tstart: start,\n\t\t\tinstall: function (target, source) {\n\t\t\t\tsetTimeout(function () {\n\t\t\t\t\tstart && start.execute(runtime.makeContext(target, initFeature, target, null));\n\t\t\t\t}, 0);\n\t\t\t},\n\t\t};\n\n\t\t// terminate body\n\t\tparser.ensureTerminated(start);\n\t\tparser.setParent(start, initFeature);\n\t\treturn initFeature;\n\t});\n\n\t_parser.addFeature(\"worker\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"worker\")) {\n\t\t\tparser.raiseParseError(\n\t\t\t\ttokens,\n\t\t\t\t\"In order to use the 'worker' feature, include \" +\n\t\t\t\t\t\"the _hyperscript worker plugin. See \" +\n\t\t\t\t\t\"https://hyperscript.org/features/worker/ for \" +\n\t\t\t\t\t\"more info.\"\n\t\t\t);\n\t\t}\n\t});\n\n\t_parser.addFeature(\"behavior\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"behavior\")) return;\n\t\tvar path = parser.requireElement(\"dotOrColonPath\", tokens).evaluate();\n\t\tvar nameSpace = path.split(\".\");\n\t\tvar name = nameSpace.pop();\n\n\t\tvar formalParams = [];\n\t\tif (tokens.matchOpToken(\"(\") && !tokens.matchOpToken(\")\")) {\n\t\t\tdo {\n\t\t\t\tformalParams.push(tokens.requireTokenType(\"IDENTIFIER\").value);\n\t\t\t} while (tokens.matchOpToken(\",\"));\n\t\t\ttokens.requireOpToken(\")\");\n\t\t}\n\t\tvar hs = parser.requireElement(\"hyperscript\", tokens);\n\t\tfor (var i = 0; i < hs.features.length; i++) {\n\t\t\tvar feature = hs.features[i];\n\t\t\tfeature.behavior = path;\n\t\t}\n\n\t\treturn {\n\t\t\tinstall: function (target, source) {\n\t\t\t\truntime.assignToNamespace(\n\t\t\t\t\tglobalScope.document && globalScope.document.body,\n\t\t\t\t\tnameSpace,\n\t\t\t\t\tname,\n\t\t\t\t\tfunction (target, source, innerArgs) {\n\t\t\t\t\t\tvar internalData = runtime.getInternalData(target);\n\t\t\t\t\t\tvar elementScope = getOrInitObject(internalData, path + \"Scope\");\n\t\t\t\t\t\tfor (var i = 0; i < formalParams.length; i++) {\n\t\t\t\t\t\t\telementScope[formalParams[i]] = innerArgs[formalParams[i]];\n\t\t\t\t\t\t}\n\t\t\t\t\t\ths.apply(target, source);\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addFeature(\"install\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"install\")) return;\n\t\tvar behaviorPath = parser.requireElement(\"dotOrColonPath\", tokens).evaluate();\n\t\tvar behaviorNamespace = behaviorPath.split(\".\");\n\t\tvar args = parser.parseElement(\"namedArgumentList\", tokens);\n\n\t\tvar installFeature;\n\t\treturn (installFeature = {\n\t\t\tinstall: function (target, source) {\n\t\t\t\truntime.unifiedEval(\n\t\t\t\t\t{\n\t\t\t\t\t\targs: [args],\n\t\t\t\t\t\top: function (ctx, args) {\n\t\t\t\t\t\t\tvar behavior = globalScope;\n\t\t\t\t\t\t\tfor (var i = 0; i < behaviorNamespace.length; i++) {\n\t\t\t\t\t\t\t\tbehavior = behavior[behaviorNamespace[i]];\n\t\t\t\t\t\t\t\tif (typeof behavior !== \"object\" && typeof behavior !== \"function\")\n\t\t\t\t\t\t\t\t\tthrow new Error(\"No such behavior defined as \" + behaviorPath);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (!(behavior instanceof Function))\n\t\t\t\t\t\t\t\tthrow new Error(behaviorPath + \" is not a behavior\");\n\n\t\t\t\t\t\t\tbehavior(target, source, args);\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\truntime.makeContext(target, installFeature, target)\n\t\t\t\t);\n\t\t\t},\n\t\t});\n\t});\n\n\t_parser.addGrammarElement(\"jsBody\", function (parser, runtime, tokens) {\n\t\tvar jsSourceStart = tokens.currentToken().start;\n\t\tvar jsLastToken = tokens.currentToken();\n\n\t\tvar funcNames = [];\n\t\tvar funcName = \"\";\n\t\tvar expectFunctionDeclaration = false;\n\t\twhile (tokens.hasMore()) {\n\t\t\tjsLastToken = tokens.consumeToken();\n\t\t\tvar peek = tokens.token(0, true);\n\t\t\tif (peek.type === \"IDENTIFIER\" && peek.value === \"end\") {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (expectFunctionDeclaration) {\n\t\t\t\tif (jsLastToken.type === \"IDENTIFIER\" || jsLastToken.type === \"NUMBER\") {\n\t\t\t\t\tfuncName += jsLastToken.value;\n\t\t\t\t} else {\n\t\t\t\t\tif (funcName !== \"\") funcNames.push(funcName);\n\t\t\t\t\tfuncName = \"\";\n\t\t\t\t\texpectFunctionDeclaration = false;\n\t\t\t\t}\n\t\t\t} else if (jsLastToken.type === \"IDENTIFIER\" && jsLastToken.value === \"function\") {\n\t\t\t\texpectFunctionDeclaration = true;\n\t\t\t}\n\t\t}\n\t\tvar jsSourceEnd = jsLastToken.end + 1;\n\n\t\treturn {\n\t\t\ttype: \"jsBody\",\n\t\t\texposedFunctionNames: funcNames,\n\t\t\tjsSource: tokens.source.substring(jsSourceStart, jsSourceEnd),\n\t\t};\n\t});\n\n\t_parser.addFeature(\"js\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"js\")) return;\n\t\tvar jsBody = parser.requireElement(\"jsBody\", tokens);\n\n\t\tvar jsSource =\n\t\t\tjsBody.jsSource +\n\t\t\t\"\\nreturn { \" +\n\t\t\tjsBody.exposedFunctionNames\n\t\t\t\t.map(function (name) {\n\t\t\t\t\treturn name + \":\" + name;\n\t\t\t\t})\n\t\t\t\t.join(\",\") +\n\t\t\t\" } \";\n\t\tvar func = new Function(jsSource);\n\n\t\treturn {\n\t\t\tjsSource: jsSource,\n\t\t\tfunction: func,\n\t\t\texposedFunctionNames: jsBody.exposedFunctionNames,\n\t\t\tinstall: function () {\n\t\t\t\tmergeObjects(globalScope, func());\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addCommand(\"js\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"js\")) return;\n\t\t// Parse inputs\n\t\tvar inputs = [];\n\t\tif (tokens.matchOpToken(\"(\")) {\n\t\t\tif (tokens.matchOpToken(\")\")) {\n\t\t\t\t// empty input list\n\t\t\t} else {\n\t\t\t\tdo {\n\t\t\t\t\tvar inp = tokens.requireTokenType(\"IDENTIFIER\");\n\t\t\t\t\tinputs.push(inp.value);\n\t\t\t\t} while (tokens.matchOpToken(\",\"));\n\t\t\t\ttokens.requireOpToken(\")\");\n\t\t\t}\n\t\t}\n\n\t\tvar jsBody = parser.requireElement(\"jsBody\", tokens);\n\t\ttokens.matchToken(\"end\");\n\n\t\tvar func = varargConstructor(Function, inputs.concat([jsBody.jsSource]));\n\n\t\tvar command = {\n\t\t\tjsSource: jsBody.jsSource,\n\t\t\tfunction: func,\n\t\t\tinputs: inputs,\n\t\t\top: function (context) {\n\t\t\t\tvar args = [];\n\t\t\t\tinputs.forEach(function (input) {\n\t\t\t\t\targs.push(runtime.resolveSymbol(input, context, 'default'));\n\t\t\t\t});\n\t\t\t\tvar result = func.apply(globalScope, args);\n\t\t\t\tif (result && typeof result.then === \"function\") {\n\t\t\t\t\treturn new Promise(function (resolve) {\n\t\t\t\t\t\tresult.then(function (actualResult) {\n\t\t\t\t\t\t\tcontext.result = actualResult;\n\t\t\t\t\t\t\tresolve(runtime.findNext(this, context));\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tcontext.result = result;\n\t\t\t\t\treturn runtime.findNext(this, context);\n\t\t\t\t}\n\t\t\t},\n\t\t};\n\t\treturn command;\n\t});\n\n\t_parser.addCommand(\"async\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"async\")) return;\n\t\tif (tokens.matchToken(\"do\")) {\n\t\t\tvar body = parser.requireElement(\"commandList\", tokens);\n\n\t\t\t// Append halt\n\t\t\tvar end = body;\n\t\t\twhile (end.next) end = end.next;\n\t\t\tend.next = runtime.HALT;\n\n\t\t\ttokens.requireToken(\"end\");\n\t\t} else {\n\t\t\tvar body = parser.requireElement(\"command\", tokens);\n\t\t}\n\t\tvar command = {\n\t\t\tbody: body,\n\t\t\top: function (context) {\n\t\t\t\tsetTimeout(function () {\n\t\t\t\t\tbody.execute(context);\n\t\t\t\t});\n\t\t\t\treturn runtime.findNext(this, context);\n\t\t\t},\n\t\t};\n\t\tparser.setParent(body, command);\n\t\treturn command;\n\t});\n\n\t_parser.addCommand(\"tell\", function (parser, runtime, tokens) {\n\t\tvar startToken = tokens.currentToken();\n\t\tif (!tokens.matchToken(\"tell\")) return;\n\t\tvar value = parser.requireElement(\"expression\", tokens);\n\t\tvar body = parser.requireElement(\"commandList\", tokens);\n\t\tif (tokens.hasMore() && !parser.featureStart(tokens.currentToken())) {\n\t\t\ttokens.requireToken(\"end\");\n\t\t}\n\t\tvar slot = \"tell_\" + startToken.start;\n\t\tvar tellCmd = {\n\t\t\tvalue: value,\n\t\t\tbody: body,\n\t\t\targs: [value],\n\t\t\tresolveNext: function (context) {\n\t\t\t\tvar iterator = context.meta.iterators[slot];\n\t\t\t\tif (iterator.index < iterator.value.length) {\n\t\t\t\t\tcontext.beingTold = iterator.value[iterator.index++];\n\t\t\t\t\treturn body;\n\t\t\t\t} else {\n\t\t\t\t\t// restore original me\n\t\t\t\t\tcontext.beingTold = iterator.originalBeingTold;\n\t\t\t\t\tif (this.next) {\n\t\t\t\t\t\treturn this.next;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn runtime.findNext(this.parent, context);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\top: function (context, value) {\n\t\t\t\tif (value == null) {\n\t\t\t\t\tvalue = [];\n\t\t\t\t} else if (!(Array.isArray(value) || value instanceof NodeList)) {\n\t\t\t\t\tvalue = [value];\n\t\t\t\t}\n\t\t\t\tcontext.meta.iterators[slot] = {\n\t\t\t\t\toriginalBeingTold: context.beingTold,\n\t\t\t\t\tindex: 0,\n\t\t\t\t\tvalue: value,\n\t\t\t\t};\n\t\t\t\treturn this.resolveNext(context);\n\t\t\t},\n\t\t};\n\t\tparser.setParent(body, tellCmd);\n\t\treturn tellCmd;\n\t});\n\n\t_parser.addCommand(\"wait\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"wait\")) return;\n\t\tvar command;\n\n\t\t// wait on event\n\t\tif (tokens.matchToken(\"for\")) {\n\t\t\ttokens.matchToken(\"a\"); // optional \"a\"\n\t\t\tvar events = [];\n\t\t\tdo {\n\t\t\t\tvar lookahead = tokens.token(0);\n\t\t\t\tif (lookahead.type === 'NUMBER' || lookahead.type === 'L_PAREN') {\n\t\t\t\t\tevents.push({\n\t\t\t\t\t\ttime: parser.requireElement('expression', tokens).evaluate() // TODO: do we want to allow async here?\n\t\t\t\t\t})\n\t\t\t\t} else {\n\t\t\t\t\tevents.push({\n\t\t\t\t\t\tname: _parser.requireElement(\"dotOrColonPath\", tokens, \"Expected event name\").evaluate(),\n\t\t\t\t\t\targs: parseEventArgs(tokens),\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} while (tokens.matchToken(\"or\"));\n\n\t\t\tif (tokens.matchToken(\"from\")) {\n\t\t\t\tvar on = parser.requireElement(\"expression\", tokens);\n\t\t\t}\n\n\t\t\t// wait on event\n\t\t\tcommand = {\n\t\t\t\tevent: events,\n\t\t\t\ton: on,\n\t\t\t\targs: [on],\n\t\t\t\top: function (context, on) {\n\t\t\t\t\tvar target = on ? on : context.me;\n\t\t\t\t\tif (!(target instanceof EventTarget))\n\t\t\t\t\t\tthrow new Error(\"Not a valid event target: \" + this.on.sourceFor());\n\t\t\t\t\treturn new Promise((resolve) => {\n\t\t\t\t\t\tvar resolved = false;\n\t\t\t\t\t\tfor (const eventInfo of events) {\n\t\t\t\t\t\t\tvar listener = (event) => {\n\t\t\t\t\t\t\t\tcontext.result = event;\n\t\t\t\t\t\t\t\tif (eventInfo.args) {\n\t\t\t\t\t\t\t\t\tfor (const arg of eventInfo.args) {\n\t\t\t\t\t\t\t\t\t\tcontext[arg.value] =\n\t\t\t\t\t\t\t\t\t\t\tevent[arg.value] || (event.detail ? event.detail[arg.value] : null);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (!resolved) {\n\t\t\t\t\t\t\t\t\tresolved = true;\n\t\t\t\t\t\t\t\t\tresolve(runtime.findNext(this, context));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tif (eventInfo.name){\n\t\t\t\t\t\t\t\ttarget.addEventListener(eventInfo.name, listener, {once: true});\n\t\t\t\t\t\t\t} else if (eventInfo.time != null) {\n\t\t\t\t\t\t\t\tsetTimeout(listener, eventInfo.time, eventInfo.time)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t};\n\t\t\treturn command;\n\t\t} else {\n\t\t\tvar time;\n\t\t\tif (tokens.matchToken(\"a\")) {\n\t\t\t\ttokens.requireToken(\"tick\");\n\t\t\t\ttime = 0;\n\t\t\t} else {\n\t\t\t\ttime = _parser.requireElement(\"expression\", tokens);\n\t\t\t}\n\n\t\t\tcommand = {\n\t\t\t\ttype: \"waitCmd\",\n\t\t\t\ttime: time,\n\t\t\t\targs: [time],\n\t\t\t\top: function (context, timeValue) {\n\t\t\t\t\treturn new Promise((resolve) => {\n\t\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\t\tresolve(runtime.findNext(this, context));\n\t\t\t\t\t\t}, timeValue);\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\texecute: function (context) {\n\t\t\t\t\treturn runtime.unifiedExec(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t\treturn command;\n\t\t}\n\t});\n\n\t// TODO  - colon path needs to eventually become part of ruby-style symbols\n\t_parser.addGrammarElement(\"dotOrColonPath\", function (parser, runtime, tokens) {\n\t\tvar root = tokens.matchTokenType(\"IDENTIFIER\");\n\t\tif (root) {\n\t\t\tvar path = [root.value];\n\n\t\t\tvar separator = tokens.matchOpToken(\".\") || tokens.matchOpToken(\":\");\n\t\t\tif (separator) {\n\t\t\t\tdo {\n\t\t\t\t\tpath.push(tokens.requireTokenType(\"IDENTIFIER\", \"NUMBER\").value);\n\t\t\t\t} while (tokens.matchOpToken(separator.value));\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\ttype: \"dotOrColonPath\",\n\t\t\t\tpath: path,\n\t\t\t\tevaluate: function () {\n\t\t\t\t\treturn path.join(separator ? separator.value : \"\");\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t});\n\n\n\t_parser.addGrammarElement(\"eventName\", function (parser, runtime, tokens) {\n\t\tvar token;\n\t\tif ((token = tokens.matchTokenType(\"STRING\"))) {\n\t\t\treturn {\n\t\t\t\tevaluate: function() {\n\t\t\t\t\treturn token.value;\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\n\t\treturn parser.parseElement(\"dotOrColonPath\", tokens);\n\t});\n\n\tfunction parseSendCmd(cmdType, parser, runtime, tokens) {\n\t\tvar eventName = parser.requireElement(\"eventName\", tokens);\n\n\t\tvar details = parser.parseElement(\"namedArgumentList\", tokens);\n\t\tif ((cmdType === \"send\" && tokens.matchToken(\"to\")) ||\n\t\t\t(cmdType === \"trigger\" && tokens.matchToken(\"on\"))) {\n\t\t\tvar toExpr = parser.requireElement(\"expression\", tokens);\n\t\t} else {\n\t\t\tvar toExpr = parser.requireElement(\"implicitMeTarget\", tokens);\n\t\t}\n\n\t\tvar sendCmd = {\n\t\t\teventName: eventName,\n\t\t\tdetails: details,\n\t\t\tto: toExpr,\n\t\t\targs: [toExpr, eventName, details],\n\t\t\top: function (context, to, eventName, details) {\n\t\t\t\truntime.nullCheck(to, toExpr);\n\t\t\t\truntime.forEach(to, function (target) {\n\t\t\t\t\truntime.triggerEvent(target, eventName, details, context.me);\n\t\t\t\t});\n\t\t\t\treturn runtime.findNext(sendCmd, context);\n\t\t\t},\n\t\t};\n\t\treturn sendCmd;\n\t}\n\n\t_parser.addCommand(\"trigger\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"trigger\")) {\n\t\t\treturn parseSendCmd(\"trigger\", parser, runtime, tokens);\n\t\t}\n\t});\n\n\t_parser.addCommand(\"send\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"send\")) {\n\t\t\treturn parseSendCmd(\"send\", parser, runtime, tokens);\n\t\t}\n\t});\n\n\tvar parseReturnFunction = function (parser, runtime, tokens, returnAValue) {\n\t\tif (returnAValue) {\n\t\t\tif (parser.commandBoundary(tokens.currentToken())) {\n\t\t\t\tparser.raiseParseError(tokens, \"'return' commands must return a value.  If you do not wish to return a value, use 'exit' instead.\");\n\t\t\t} else {\n\t\t\t\tvar value = parser.requireElement(\"expression\", tokens);\n\t\t\t}\n\t\t}\n\n\t\tvar returnCmd = {\n\t\t\tvalue: value,\n\t\t\targs: [value],\n\t\t\top: function (context, value) {\n\t\t\t\tvar resolve = context.meta.resolve;\n\t\t\t\tcontext.meta.returned = true;\n\t\t\t\tcontext.meta.returnValue = value;\n\t\t\t\tif (resolve) {\n\t\t\t\t\tif (value) {\n\t\t\t\t\t\tresolve(value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn runtime.HALT;\n\t\t\t},\n\t\t};\n\t\treturn returnCmd;\n\t};\n\n\t_parser.addCommand(\"return\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"return\")) {\n\t\t\treturn parseReturnFunction(parser, runtime, tokens, true);\n\t\t}\n\t});\n\n\t_parser.addCommand(\"exit\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"exit\")) {\n\t\t\treturn parseReturnFunction(parser, runtime, tokens, false);\n\t\t}\n\t});\n\n\t_parser.addCommand(\"halt\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"halt\")) {\n\t\t\tif (tokens.matchToken(\"the\")) {\n\t\t\t\ttokens.requireToken(\"event\");\n\t\t\t\t// optional possessive\n\t\t\t\tif (tokens.matchOpToken(\"'\")) {\n\t\t\t\t\ttokens.requireToken(\"s\");\n\t\t\t\t}\n\t\t\t\tvar keepExecuting = true;\n\t\t\t}\n\t\t\tif (tokens.matchToken(\"bubbling\")) {\n\t\t\t\tvar bubbling = true;\n\t\t\t} else if (tokens.matchToken(\"default\")) {\n\t\t\t\tvar haltDefault = true;\n\t\t\t}\n\t\t\tvar exit = parseReturnFunction(parser, runtime, tokens, false);\n\n\t\t\tvar haltCmd = {\n\t\t\t\tkeepExecuting: true,\n\t\t\t\tbubbling: bubbling,\n\t\t\t\thaltDefault: haltDefault,\n\t\t\t\texit: exit,\n\t\t\t\top: function (ctx) {\n\t\t\t\t\tif (ctx.event) {\n\t\t\t\t\t\tif (bubbling) {\n\t\t\t\t\t\t\tctx.event.stopPropagation();\n\t\t\t\t\t\t} else if (haltDefault) {\n\t\t\t\t\t\t\tctx.event.preventDefault();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tctx.event.stopPropagation();\n\t\t\t\t\t\t\tctx.event.preventDefault();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (keepExecuting) {\n\t\t\t\t\t\t\treturn runtime.findNext(this, ctx);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn exit;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t};\n\t\t\treturn haltCmd;\n\t\t}\n\t});\n\n\t_parser.addCommand(\"log\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"log\")) return;\n\t\tvar exprs = [parser.parseElement(\"expression\", tokens)];\n\t\twhile (tokens.matchOpToken(\",\")) {\n\t\t\texprs.push(parser.requireElement(\"expression\", tokens));\n\t\t}\n\t\tif (tokens.matchToken(\"with\")) {\n\t\t\tvar withExpr = parser.requireElement(\"expression\", tokens);\n\t\t}\n\t\tvar logCmd = {\n\t\t\texprs: exprs,\n\t\t\twithExpr: withExpr,\n\t\t\targs: [withExpr, exprs],\n\t\t\top: function (ctx, withExpr, values) {\n\t\t\t\tif (withExpr) {\n\t\t\t\t\twithExpr.apply(null, values);\n\t\t\t\t} else {\n\t\t\t\t\tconsole.log.apply(null, values);\n\t\t\t\t}\n\t\t\t\treturn runtime.findNext(this, ctx);\n\t\t\t},\n\t\t};\n\t\treturn logCmd;\n\t});\n\n\t_parser.addCommand(\"throw\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"throw\")) return;\n\t\tvar expr = parser.requireElement(\"expression\", tokens);\n\t\tvar throwCmd = {\n\t\t\texpr: expr,\n\t\t\targs: [expr],\n\t\t\top: function (ctx, expr) {\n\t\t\t\truntime.registerHyperTrace(ctx, expr);\n\t\t\t\tthrow expr;\n\t\t\t},\n\t\t};\n\t\treturn throwCmd;\n\t});\n\n\tvar parseCallOrGet = function (parser, runtime, tokens) {\n\t\tvar expr = parser.requireElement(\"expression\", tokens);\n\t\tvar callCmd = {\n\t\t\texpr: expr,\n\t\t\targs: [expr],\n\t\t\top: function (context, result) {\n\t\t\t\tcontext.result = result;\n\t\t\t\treturn runtime.findNext(callCmd, context);\n\t\t\t},\n\t\t};\n\t\treturn callCmd;\n\t};\n\t_parser.addCommand(\"call\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"call\")) return;\n\t\tvar call = parseCallOrGet(parser, runtime, tokens);\n\t\tif (call.expr && call.expr.type !== \"functionCall\") {\n\t\t\tparser.raiseParseError(tokens, \"Must be a function invocation\");\n\t\t}\n\t\treturn call;\n\t});\n\t_parser.addCommand(\"get\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"get\")) {\n\t\t\treturn parseCallOrGet(parser, runtime, tokens);\n\t\t}\n\t});\n\n\t_parser.addCommand(\"make\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"make\")) return;\n\t\ttokens.matchToken(\"a\") || tokens.matchToken(\"an\");\n\n\t\tvar expr = parser.requireElement(\"expression\", tokens);\n\n\t\tvar args = [];\n\t\tif (expr.type !== \"queryRef\" && tokens.matchToken(\"from\")) {\n\t\t\tdo {\n\t\t\t\targs.push(parser.requireElement(\"expression\", tokens));\n\t\t\t} while (tokens.matchOpToken(\",\"));\n\t\t}\n\n\t\tif (tokens.matchToken(\"called\")) {\n\t\t\tvar target = parser.requireElement(\"symbol\", tokens);\n\t\t}\n\n\t\tvar command;\n\t\tif (expr.type === \"queryRef\") {\n\t\t\tcommand = {\n\t\t\t\top: function (ctx) {\n\t\t\t\t\tvar match,\n\t\t\t\t\t\ttagname = \"div\",\n\t\t\t\t\t\tid,\n\t\t\t\t\t\tclasses = [];\n\t\t\t\t\tvar re = /(?:(^|#|\\.)([^#\\. ]+))/g;\n\t\t\t\t\twhile ((match = re.exec(expr.css))) {\n\t\t\t\t\t\tif (match[1] === \"\") tagname = match[2].trim();\n\t\t\t\t\t\telse if (match[1] === \"#\") id = match[2].trim();\n\t\t\t\t\t\telse classes.push(match[2].trim());\n\t\t\t\t\t}\n\n\t\t\t\t\tvar result = document.createElement(tagname);\n\t\t\t\t\tif (id !== undefined) result.id = id;\n\t\t\t\t\tfor (var i = 0; i < classes.length; i++) {\n\t\t\t\t\t\tvar cls = classes[i];\n\t\t\t\t\t\tresult.classList.add(cls)\n\t\t\t\t\t}\n\n\t\t\t\t\tctx.result = result;\n\t\t\t\t\tif (target){\n\t\t\t\t\t\truntime.setSymbol(target.name, ctx, target.scope, result);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn runtime.findNext(this, ctx);\n\t\t\t\t},\n\t\t\t};\n\t\t\treturn command;\n\t\t} else {\n\t\t\tcommand = {\n\t\t\t\targs: [expr, args],\n\t\t\t\top: function (ctx, expr, args) {\n\t\t\t\t\tctx.result = varargConstructor(expr, args);\n\t\t\t\t\tif (target){\n\t\t\t\t\t\truntime.setSymbol(target.name, ctx, target.scope, ctx.result);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn runtime.findNext(this, ctx);\n\t\t\t\t},\n\t\t\t};\n\t\t\treturn command;\n\t\t}\n\t});\n\n\t_parser.addGrammarElement(\"pseudoCommand\", function (parser, runtime, tokens) {\n\n\t\tlet lookAhead = tokens.token(1);\n\t\tif (!(lookAhead && lookAhead.op && (lookAhead.value === '.' || lookAhead.value === \"(\"))) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar expr = parser.requireElement(\"primaryExpression\", tokens);\n\n\t\tvar rootRoot = expr.root;\n\t\tvar root = expr;\n\t\twhile (rootRoot.root != null) {\n\t\t\troot = root.root;\n\t\t\trootRoot = rootRoot.root;\n\t\t}\n\n\t\tif (expr.type !== \"functionCall\") {\n\t\t\tparser.raiseParseError(tokens, \"Pseudo-commands must be function calls\");\n\t\t}\n\n\t\tif (root.type === \"functionCall\" && root.root.root == null) {\n\t\t\tif (tokens.matchAnyToken(\"the\", \"to\", \"on\", \"with\", \"into\", \"from\", \"at\")) {\n\t\t\t\tvar realRoot = parser.requireElement(\"expression\", tokens);\n\t\t\t} else if (tokens.matchToken(\"me\")) {\n\t\t\t\tvar realRoot = parser.requireElement(\"implicitMeTarget\", tokens);\n\t\t\t}\n\t\t}\n\n\t\t/** @type {GrammarElement} */\n\n\t\tif(realRoot){\n\t\t\tvar pseudoCommand = {\n\t\t\t\ttype: \"pseudoCommand\",\n\t\t\t\troot: realRoot,\n\t\t\t\targExressions: root.argExressions,\n\t\t\t\targs: [realRoot, root.argExressions],\n\t\t\t\top: function (context, rootRoot, args) {\n\t\t\t\t\truntime.nullCheck(rootRoot, realRoot);\n\t\t\t\t\tvar func = rootRoot[root.root.name];\n\t\t\t\t\truntime.nullCheck(func, root);\n\t\t\t\t\tif (func.hyperfunc) {\n\t\t\t\t\t\targs.push(context);\n\t\t\t\t\t}\n\t\t\t\t\tcontext.result = func.apply(rootRoot, args);\n\t\t\t\t\treturn runtime.findNext(pseudoCommand, context);\n\t\t\t\t},\n\t\t\t\texecute: function (context) {\n\t\t\t\t\treturn runtime.unifiedExec(this, context);\n\t\t\t\t},\n\t\t\t}\n\t\t} else {\n\t\t\tvar pseudoCommand = {\n\t\t\t\ttype: \"pseudoCommand\",\n\t\t\t\texpr: expr,\n\t\t\t\targs: [expr],\n\t\t\t\top: function (context, result) {\n\t\t\t\t\tcontext.result = result;\n\t\t\t\t\treturn runtime.findNext(pseudoCommand, context);\n\t\t\t\t},\n\t\t\t\texecute: function (context) {\n\t\t\t\t\treturn runtime.unifiedExec(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\n\t\treturn pseudoCommand;\n\t});\n\n\t/**\n\t* @param {ParserObject} parser\n\t* @param {RuntimeObject} runtime\n\t* @param {TokensObject} tokens\n\t* @param {*} target\n\t* @param {*} value\n\t* @returns\n\t*/\n\tvar makeSetter = function (parser, runtime, tokens, target, value) {\n\n\t\tvar symbolWrite = target.type === \"symbol\";\n\t\tvar attributeWrite = target.type === \"attributeRef\";\n\t\tvar styleWrite = target.type === \"styleRef\";\n\t\tvar arrayWrite = target.type === \"arrayIndex\";\n\n\t\tif (!(attributeWrite || styleWrite || symbolWrite) && target.root == null) {\n\t\t\tparser.raiseParseError(tokens, \"Can only put directly into symbols, not references\");\n\t\t}\n\n\t\tvar rootElt = null;\n\t\tvar prop = null;\n\t\tif (symbolWrite) {\n\t\t\t// rootElt is null\n\t\t} else if (attributeWrite || styleWrite) {\n\t\t\trootElt = parser.requireElement(\"implicitMeTarget\", tokens);\n\t\t\tvar attribute = target;\n\t\t} else if(arrayWrite) {\n\t\t\tprop = target.firstIndex;\n\t\t\trootElt = target.root;\n\t\t} else {\n\t\t\tprop = target.prop ? target.prop.value : null;\n\t\t\tvar attribute = target.attribute;\n\t\t\trootElt = target.root;\n\t\t}\n\n\t\t/** @type {GrammarElement} */\n\t\tvar setCmd = {\n\t\t\ttarget: target,\n\t\t\tsymbolWrite: symbolWrite,\n\t\t\tvalue: value,\n\t\t\targs: [rootElt, prop, value],\n\t\t\top: function (context, root, prop, valueToSet) {\n\t\t\t\tif (symbolWrite) {\n\t\t\t\t\truntime.setSymbol(target.name, context, target.scope, valueToSet);\n\t\t\t\t} else {\n\t\t\t\t\truntime.nullCheck(root, rootElt);\n\t\t\t\t\tif (arrayWrite) {\n\t\t\t\t\t\troot[prop] = valueToSet;\n\t\t\t\t\t} else {\n\t\t\t\t\t\truntime.implicitLoop(root, function (elt) {\n\t\t\t\t\t\t\tif (attribute) {\n\t\t\t\t\t\t\t\tif (attribute.type === \"attributeRef\") {\n\t\t\t\t\t\t\t\t\tif (valueToSet == null) {\n\t\t\t\t\t\t\t\t\t\telt.removeAttribute(attribute.name);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\telt.setAttribute(attribute.name, valueToSet);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\telt.style[attribute.name] = valueToSet;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\telt[prop] = valueToSet;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn runtime.findNext(this, context);\n\t\t\t},\n\t\t};\n\t\treturn setCmd;\n\t};\n\n\t_parser.addCommand(\"default\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"default\")) return;\n\t\tvar target = parser.requireElement(\"assignableExpression\", tokens);\n\t\ttokens.requireToken(\"to\");\n\n\t\tvar value = parser.requireElement(\"expression\", tokens);\n\n\t\t/** @type {GrammarElement} */\n\t\tvar setter = makeSetter(parser, runtime, tokens, target, value);\n\t\tvar defaultCmd = {\n\t\t\ttarget: target,\n\t\t\tvalue: value,\n\t\t\tsetter: setter,\n\t\t\targs: [target],\n\t\t\top: function (context, target) {\n\t\t\t\tif (target) {\n\t\t\t\t\treturn runtime.findNext(this, context);\n\t\t\t\t} else {\n\t\t\t\t\treturn setter;\n\t\t\t\t}\n\t\t\t},\n\t\t};\n\t\tsetter.parent = defaultCmd;\n\t\treturn defaultCmd;\n\t});\n\n\t_parser.addCommand(\"set\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"set\")) return;\n\t\tif (tokens.currentToken().type === \"L_BRACE\") {\n\t\t\tvar obj = parser.requireElement(\"objectLiteral\", tokens);\n\t\t\ttokens.requireToken(\"on\");\n\t\t\tvar target = parser.requireElement(\"expression\", tokens);\n\n\t\t\tvar command = {\n\t\t\t\tobjectLiteral: obj,\n\t\t\t\ttarget: target,\n\t\t\t\targs: [obj, target],\n\t\t\t\top: function (ctx, obj, target) {\n\t\t\t\t\tmergeObjects(target, obj);\n\t\t\t\t\treturn runtime.findNext(this, ctx);\n\t\t\t\t},\n\t\t\t};\n\t\t\treturn command;\n\t\t}\n\n\t\ttry {\n\t\t\ttokens.pushFollow(\"to\");\n\t\t\tvar target = parser.requireElement(\"assignableExpression\", tokens);\n\t\t} finally {\n\t\t\ttokens.popFollow();\n\t\t}\n\t\ttokens.requireToken(\"to\");\n\t\tvar value = parser.requireElement(\"expression\", tokens);\n\t\treturn makeSetter(parser, runtime, tokens, target, value);\n\t});\n\n\t_parser.addCommand(\"if\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"if\")) return;\n\t\tvar expr = parser.requireElement(\"expression\", tokens);\n\t\ttokens.matchToken(\"then\"); // optional 'then'\n\t\tvar trueBranch = parser.parseElement(\"commandList\", tokens);\n\t\tif (tokens.matchToken(\"else\") || tokens.matchToken(\"otherwise\")) {\n\t\t\tvar falseBranch = parser.parseElement(\"commandList\", tokens);\n\t\t}\n\t\tif (tokens.hasMore()) {\n\t\t\ttokens.requireToken(\"end\");\n\t\t}\n\n\t\t/** @type {GrammarElement} */\n\t\tvar ifCmd = {\n\t\t\texpr: expr,\n\t\t\ttrueBranch: trueBranch,\n\t\t\tfalseBranch: falseBranch,\n\t\t\targs: [expr],\n\t\t\top: function (context, exprValue) {\n\t\t\t\tif (exprValue) {\n\t\t\t\t\treturn trueBranch;\n\t\t\t\t} else if (falseBranch) {\n\t\t\t\t\treturn falseBranch;\n\t\t\t\t} else {\n\t\t\t\t\treturn runtime.findNext(this, context);\n\t\t\t\t}\n\t\t\t},\n\t\t};\n\t\tparser.setParent(trueBranch, ifCmd);\n\t\tparser.setParent(falseBranch, ifCmd);\n\t\treturn ifCmd;\n\t});\n\n\tvar parseRepeatExpression = function (parser, tokens, runtime, startedWithForToken) {\n\t\tvar innerStartToken = tokens.currentToken();\n\t\tvar identifier;\n\t\tif (tokens.matchToken(\"for\") || startedWithForToken) {\n\t\t\tvar identifierToken = tokens.requireTokenType(\"IDENTIFIER\");\n\t\t\tidentifier = identifierToken.value;\n\t\t\ttokens.requireToken(\"in\");\n\t\t\tvar expression = parser.requireElement(\"expression\", tokens);\n\t\t} else if (tokens.matchToken(\"in\")) {\n\t\t\tidentifier = \"it\";\n\t\t\tvar expression = parser.requireElement(\"expression\", tokens);\n\t\t} else if (tokens.matchToken(\"while\")) {\n\t\t\tvar whileExpr = parser.requireElement(\"expression\", tokens);\n\t\t} else if (tokens.matchToken(\"until\")) {\n\t\t\tvar isUntil = true;\n\t\t\tif (tokens.matchToken(\"event\")) {\n\t\t\t\tvar evt = _parser.requireElement(\"dotOrColonPath\", tokens, \"Expected event name\");\n\t\t\t\tif (tokens.matchToken(\"from\")) {\n\t\t\t\t\tvar on = parser.requireElement(\"expression\", tokens);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar whileExpr = parser.requireElement(\"expression\", tokens);\n\t\t\t}\n\t\t} else {\n\t\t\tif (!parser.commandBoundary(tokens.currentToken()) &&\n\t\t\t    tokens.currentToken().value !== 'forever') {\n\t\t\t\tvar times = parser.requireElement(\"expression\", tokens);\n\t\t\t\ttokens.requireToken(\"times\");\n\t\t\t} else {\n\t\t\t\ttokens.matchToken(\"forever\"); // consume optional forever\n\t\t\t\tvar forever = true;\n\t\t\t}\n\t\t}\n\n\t\tif (tokens.matchToken(\"index\")) {\n\t\t\tvar identifierToken = tokens.requireTokenType(\"IDENTIFIER\");\n\t\t\tvar indexIdentifier = identifierToken.value;\n\t\t}\n\n\t\tvar loop = parser.parseElement(\"commandList\", tokens);\n\t\tif (loop && evt) {\n\t\t\t// if this is an event based loop, wait a tick at the end of the loop so that\n\t\t\t// events have a chance to trigger in the loop condition o_O)))\n\t\t\tvar last = loop;\n\t\t\twhile (last.next) {\n\t\t\t\tlast = last.next;\n\t\t\t}\n\t\t\tvar waitATick = {\n\t\t\t\ttype: \"waitATick\",\n\t\t\t\top: function () {\n\t\t\t\t\treturn new Promise(function (resolve) {\n\t\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\t\tresolve(runtime.findNext(waitATick));\n\t\t\t\t\t\t}, 0);\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t};\n\t\t\tlast.next = waitATick;\n\t\t}\n\t\tif (tokens.hasMore()) {\n\t\t\ttokens.requireToken(\"end\");\n\t\t}\n\n\t\tif (identifier == null) {\n\t\t\tidentifier = \"_implicit_repeat_\" + innerStartToken.start;\n\t\t\tvar slot = identifier;\n\t\t} else {\n\t\t\tvar slot = identifier + \"_\" + innerStartToken.start;\n\t\t}\n\n\t\tvar repeatCmd = {\n\t\t\tidentifier: identifier,\n\t\t\tindexIdentifier: indexIdentifier,\n\t\t\tslot: slot,\n\t\t\texpression: expression,\n\t\t\tforever: forever,\n\t\t\ttimes: times,\n\t\t\tuntil: isUntil,\n\t\t\tevent: evt,\n\t\t\ton: on,\n\t\t\twhileExpr: whileExpr,\n\t\t\tresolveNext: function () {\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tloop: loop,\n\t\t\targs: [whileExpr, times],\n\t\t\top: function (context, whileValue, times) {\n\t\t\t\tvar iteratorInfo = context.meta.iterators[slot];\n\t\t\t\tvar keepLooping = false;\n\t\t\t\tvar loopVal = null;\n\t\t\t\tif (this.forever) {\n\t\t\t\t\tkeepLooping = true;\n\t\t\t\t} else if (this.until) {\n\t\t\t\t\tif (evt) {\n\t\t\t\t\t\tkeepLooping = context.meta.iterators[slot].eventFired === false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tkeepLooping = whileValue !== true;\n\t\t\t\t\t}\n\t\t\t\t} else if (whileExpr) {\n\t\t\t\t\tkeepLooping = whileValue;\n\t\t\t\t} else if (times) {\n\t\t\t\t\tkeepLooping = iteratorInfo.index < times;\n\t\t\t\t} else {\n\t\t\t\t\tvar nextValFromIterator = iteratorInfo.iterator.next();\n\t\t\t\t\tkeepLooping = !nextValFromIterator.done;\n\t\t\t\t\tloopVal = nextValFromIterator.value;\n\t\t\t\t}\n\n\t\t\t\tif (keepLooping) {\n\t\t\t\t\tif (iteratorInfo.value) {\n\t\t\t\t\t\tcontext.result = context[identifier] = loopVal;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontext.result = iteratorInfo.index;\n\t\t\t\t\t}\n\t\t\t\t\tif (indexIdentifier) {\n\t\t\t\t\t\tcontext[indexIdentifier] = iteratorInfo.index;\n\t\t\t\t\t}\n\t\t\t\t\titeratorInfo.index++;\n\t\t\t\t\treturn loop;\n\t\t\t\t} else {\n\t\t\t\t\tcontext.meta.iterators[slot] = null;\n\t\t\t\t\treturn runtime.findNext(this.parent, context);\n\t\t\t\t}\n\t\t\t},\n\t\t};\n\t\tparser.setParent(loop, repeatCmd);\n\t\tvar repeatInit = {\n\t\t\tname: \"repeatInit\",\n\t\t\targs: [expression, evt, on],\n\t\t\top: function (context, value, event, on) {\n\t\t\t\tvar iteratorInfo = {\n\t\t\t\t\tindex: 0,\n\t\t\t\t\tvalue: value,\n\t\t\t\t\teventFired: false,\n\t\t\t\t};\n\t\t\t\tcontext.meta.iterators[slot] = iteratorInfo;\n\t\t\t\tif (value && value[Symbol.iterator]) {\n\t\t\t\t\titeratorInfo.iterator = value[Symbol.iterator]();\n\t\t\t\t}\n\t\t\t\tif (evt) {\n\t\t\t\t\tvar target = on || context.me;\n\t\t\t\t\ttarget.addEventListener(\n\t\t\t\t\t\tevent,\n\t\t\t\t\t\tfunction (e) {\n\t\t\t\t\t\t\tcontext.meta.iterators[slot].eventFired = true;\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{ once: true }\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\treturn repeatCmd; // continue to loop\n\t\t\t},\n\t\t\texecute: function (context) {\n\t\t\t\treturn runtime.unifiedExec(this, context);\n\t\t\t},\n\t\t};\n\t\tparser.setParent(repeatCmd, repeatInit);\n\t\treturn repeatInit;\n\t};\n\n\t_parser.addCommand(\"repeat\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"repeat\")) {\n\t\t\treturn parseRepeatExpression(parser, tokens, runtime, false);\n\t\t}\n\t});\n\n\t_parser.addCommand(\"for\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"for\")) {\n\t\t\treturn parseRepeatExpression(parser, tokens, runtime, true);\n\t\t}\n\t});\n\n  _parser.addCommand(\"continue\", function (parser, runtime, tokens) {\n\n    if (!tokens.matchToken(\"continue\")) return;\n\n    var command = {\n      op: function (context) {\n\n        // scan for the closest repeat statement\n        for (var parent = this.parent ; true ; parent = parent.parent) {\n\n          if (parent == undefined) {\n            parser.raiseParseError(tokens, \"Command `continue` cannot be used outside of a `repeat` loop.\")\n          }\n          if (parent.loop != undefined) {\n            return parent.resolveNext(context)\n          }\n        }\n      }\n    };\n    return command;\n  });\n\n  _parser.addCommand(\"break\", function (parser, runtime, tokens) {\n\n    if (!tokens.matchToken(\"break\")) return;\n\n    var command = {\n      op: function (context) {\n\n        // scan for the closest repeat statement\n        for (var parent = this.parent ; true ; parent = parent.parent) {\n\n          if (parent == undefined) {\n            parser.raiseParseError(tokens, \"Command `continue` cannot be used outside of a `repeat` loop.\")\n          }\n          if (parent.loop != undefined) {\n\t\t\t  return runtime.findNext(parent.parent, context);\n          }\n        }\n      }\n    };\n    return command;\n  });\n\n\t_parser.addGrammarElement(\"stringLike\", function (parser, runtime, tokens) {\n\t\treturn _parser.parseAnyOf([\"string\", \"nakedString\"], tokens);\n\t});\n\n\t_parser.addCommand(\"append\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"append\")) return;\n\t\tvar targetExpr = null;\n\n\t\tvar value = parser.requireElement(\"expression\", tokens);\n\n\t\tvar implicitResultSymbol = {\n\t\t\ttype: \"symbol\",\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.resolveSymbol(\"result\", context);\n\t\t\t},\n\t\t};\n\n\t\tif (tokens.matchToken(\"to\")) {\n\t\t\ttargetExpr = parser.requireElement(\"expression\", tokens);\n\t\t} else {\n\t\t\ttargetExpr = implicitResultSymbol;\n\t\t}\n\n\t\tvar setter = null;\n\t\tif (targetExpr.type === \"symbol\" || targetExpr.type === \"attributeRef\" || targetExpr.root != null) {\n\t\t\tsetter = makeSetter(parser, runtime, tokens, targetExpr, implicitResultSymbol);\n\t\t}\n\n\t\tvar command = {\n\t\t\tvalue: value,\n\t\t\ttarget: targetExpr,\n\t\t\targs: [targetExpr, value],\n\t\t\top: function (context, target, value) {\n\t\t\t\tif (Array.isArray(target)) {\n\t\t\t\t\ttarget.push(value);\n\t\t\t\t\treturn runtime.findNext(this, context);\n\t\t\t\t} else if (target instanceof Element) {\n\t\t\t\t\ttarget.innerHTML += value;\n\t\t\t\t\treturn runtime.findNext(this, context);\n\t\t\t\t} else if(setter) {\n\t\t\t\t\tcontext.result = (target || \"\") + value;\n\t\t\t\t\treturn setter;\n\t\t\t\t} else {\n\t\t\t\t\tthrow Error(\"Unable to append a value!\")\n\t\t\t\t}\n\t\t\t},\n\t\t\texecute: function (context) {\n\t\t\t\treturn runtime.unifiedExec(this, context/*, value, target*/);\n\t\t\t},\n\t\t};\n\n\t\tif (setter != null) {\n\t\t\tsetter.parent = command;\n\t\t}\n\n\t\treturn command;\n\t});\n\n\t_parser.addCommand(\"increment\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"increment\")) return;\n\t\tvar amount;\n\n\t\t// This is optional.  Defaults to \"result\"\n\t\tvar target = parser.parseElement(\"assignableExpression\", tokens);\n\n\t\t// This is optional. Defaults to 1.\n\t\tif (tokens.matchToken(\"by\")) {\n\t\t\tamount = parser.requireElement(\"expression\", tokens);\n\t\t}\n\n\t\tvar implicitIncrementOp = {\n\t\t\ttype: \"implicitIncrementOp\",\n\t\t\ttarget: target,\n\t\t\targs: [target, amount],\n\t\t\top: function (context, targetValue, amount) {\n\t\t\t\ttargetValue = targetValue ? parseFloat(targetValue) : 0;\n\t\t\t\tamount = amount ? parseFloat(amount) : 1;\n\t\t\t\tvar newValue = targetValue + amount;\n\t\t\t\tcontext.result = newValue;\n\t\t\t\treturn newValue;\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t}\n\t\t};\n\n\t\treturn makeSetter(parser, runtime, tokens, target, implicitIncrementOp);\n\t});\n\n\t_parser.addCommand(\"decrement\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"decrement\")) return;\n\t\tvar amount;\n\n\t\t// This is optional.  Defaults to \"result\"\n\t\tvar target = parser.parseElement(\"assignableExpression\", tokens);\n\n\t\t// This is optional. Defaults to 1.\n\t\tif (tokens.matchToken(\"by\")) {\n\t\t\tamount = parser.requireElement(\"expression\", tokens);\n\t\t}\n\n\t\tvar implicitDecrementOp = {\n\t\t\ttype: \"implicitDecrementOp\",\n\t\t\ttarget: target,\n\t\t\targs: [target, amount],\n\t\t\top: function (context, targetValue, amount) {\n\t\t\t\ttargetValue = targetValue ? parseFloat(targetValue) : 0;\n\t\t\t\tamount = amount ? parseFloat(amount) : 1;\n\t\t\t\tvar newValue = targetValue - amount;\n\t\t\t\tcontext.result = newValue;\n\t\t\t\treturn newValue;\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t}\n\t\t};\n\n\t\treturn makeSetter(parser, runtime, tokens, target, implicitDecrementOp);\n\t});\n\n\tfunction parseConversionInfo(tokens, parser) {\n\t\tvar type = \"text\";\n\t\tvar conversion;\n\t\ttokens.matchToken(\"a\") || tokens.matchToken(\"an\");\n\t\tif (tokens.matchToken(\"json\") || tokens.matchToken(\"Object\")) {\n\t\t\ttype = \"json\";\n\t\t} else if (tokens.matchToken(\"response\")) {\n\t\t\ttype = \"response\";\n\t\t} else if (tokens.matchToken(\"html\")) {\n\t\t\ttype = \"html\";\n\t\t} else if (tokens.matchToken(\"text\")) {\n\t\t\t// default, ignore\n\t\t} else {\n\t\t\tconversion = parser.requireElement(\"dotOrColonPath\", tokens).evaluate();\n\t\t}\n\t\treturn {type, conversion};\n\t}\n\n\t_parser.addCommand(\"fetch\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"fetch\")) return;\n\t\tvar url = parser.requireElement(\"stringLike\", tokens);\n\n\t\tif (tokens.matchToken(\"as\")) {\n\t\t\tvar conversionInfo = parseConversionInfo(tokens, parser);\n\t\t}\n\n\t\tif (tokens.matchToken(\"with\") && tokens.currentToken().value !== \"{\") {\n\t\t\tvar args = parser.parseElement(\"nakedNamedArgumentList\", tokens);\n\t\t} else {\n\t\t\tvar args = parser.parseElement(\"objectLiteral\", tokens);\n\t\t}\n\n\t\tif (conversionInfo == null && tokens.matchToken(\"as\")) {\n\t\t\tconversionInfo = parseConversionInfo(tokens, parser);\n\t\t}\n\n\t\tvar type = conversionInfo ? conversionInfo.type : \"text\";\n\t\tvar conversion = conversionInfo ? conversionInfo.conversion : null\n\n\t\t/** @type {GrammarElement} */\n\t\tvar fetchCmd = {\n\t\t\turl: url,\n\t\t\targExpressions: args,\n\t\t\targs: [url, args],\n\t\t\top: function (context, url, args) {\n\t\t\t\tvar detail = args || {};\n\t\t\t\tdetail[\"sender\"] = context.me;\n\t\t\t\tdetail[\"headers\"] = detail[\"headers\"] || {}\n\t\t\t\tvar abortController = new AbortController();\n\t\t\t\tlet abortListener = context.me.addEventListener('fetch:abort', function(){\n\t\t\t\t\tabortController.abort();\n\t\t\t\t}, {once: true});\n\t\t\t\tdetail['signal'] = abortController.signal;\n\t\t\t\truntime.triggerEvent(context.me, \"hyperscript:beforeFetch\", detail);\n\t\t\t\truntime.triggerEvent(context.me, \"fetch:beforeRequest\", detail);\n\t\t\t\targs = detail;\n\t\t\t\tvar finished = false;\n\t\t\t\tif (args.timeout) {\n\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\tif (!finished) {\n\t\t\t\t\t\t\tabortController.abort();\n\t\t\t\t\t\t}\n\t\t\t\t\t}, args.timeout);\n\t\t\t\t}\n\t\t\t\treturn fetch(url, args)\n\t\t\t\t\t.then(function (resp) {\n\t\t\t\t\t\tlet resultDetails = {response:resp};\n\t\t\t\t\t\truntime.triggerEvent(context.me, \"fetch:afterResponse\", resultDetails);\n\t\t\t\t\t\tresp = resultDetails.response;\n\n\t\t\t\t\t\tif (type === \"response\") {\n\t\t\t\t\t\t\tcontext.result = resp;\n\t\t\t\t\t\t\truntime.triggerEvent(context.me, \"fetch:afterRequest\", {result:resp});\n\t\t\t\t\t\t\tfinished = true;\n\t\t\t\t\t\t\treturn runtime.findNext(fetchCmd, context);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (type === \"json\") {\n\t\t\t\t\t\t\treturn resp.json().then(function (result) {\n\t\t\t\t\t\t\t\tcontext.result = result;\n\t\t\t\t\t\t\t\truntime.triggerEvent(context.me, \"fetch:afterRequest\", {result});\n\t\t\t\t\t\t\t\tfinished = true;\n\t\t\t\t\t\t\t\treturn runtime.findNext(fetchCmd, context);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn resp.text().then(function (result) {\n\t\t\t\t\t\t\tif (conversion) result = runtime.convertValue(result, conversion);\n\n\t\t\t\t\t\t\tif (type === \"html\") result = runtime.convertValue(result, \"Fragment\");\n\n\t\t\t\t\t\t\tcontext.result = result;\n\t\t\t\t\t\t\truntime.triggerEvent(context.me, \"fetch:afterRequest\", {result});\n\t\t\t\t\t\t\tfinished = true;\n\t\t\t\t\t\t\treturn runtime.findNext(fetchCmd, context);\n\t\t\t\t\t\t});\n\t\t\t\t\t})\n\t\t\t\t\t.catch(function (reason) {\n\t\t\t\t\t\truntime.triggerEvent(context.me, \"fetch:error\", {\n\t\t\t\t\t\t\treason: reason,\n\t\t\t\t\t\t});\n\t\t\t\t\t\tthrow reason;\n\t\t\t\t\t}).finally(function(){\n\t\t\t\t\t\tcontext.me.removeEventListener('fetch:abort', abortListener);\n\t\t\t\t\t});\n\t\t\t},\n\t\t};\n\t\treturn fetchCmd;\n\t});\n}\n\n//====================================================================\n// Initialization\n//====================================================================\nfunction ready(fn) {\n\tif (document.readyState !== \"loading\") {\n\t\tsetTimeout(fn);\n\t} else {\n\t\tdocument.addEventListener(\"DOMContentLoaded\", fn);\n\t}\n}\n\nfunction getMetaConfig() {\n\t/** @type {HTMLMetaElement} */\n\tvar element = document.querySelector('meta[name=\"htmx-config\"]');\n\tif (element) {\n\t\treturn parseJSON(element.content);\n\t} else {\n\t\treturn null;\n\t}\n}\n\nfunction mergeMetaConfig() {\n\tvar metaConfig = getMetaConfig();\n\tif (metaConfig) {\n\t\t_hyperscript.config = mergeObjects(_hyperscript.config, metaConfig);\n\t}\n}\n\nif (\"document\" in globalScope) {\n\t/** @type {HTMLScriptElement[]} */\n\tvar scripts = Array.from(document.querySelectorAll(\"script[type='text/hyperscript'][src]\"))\n\tPromise.all(\n\t\t\tscripts.map(function (script) {\n\t\t\t\treturn fetch(script.src)\n\t\t\t\t\t.then(function (res) {\n\t\t\t\t\t\treturn res.text();\n\t\t\t\t\t});\n\t\t\t})\n\t\t)\n\t\t.then(function (script_values) {\n\t\t\t// forEach instead of map, since the return value of .evaluate is not used by the then\n\t\t\treturn script_values.forEach(_runtime.evaluate);\n\t\t})\n\t\t.then(function () {\n\t\t\tready(function () {\n\t\t\t\tmergeMetaConfig();\n\t\t\t\t_runtime.processNode(document.documentElement);\n\t\t\t\tdocument.addEventListener(\"htmx:load\", function (/** @type {CustomEvent} */ evt) {\n\n\t\t\t\t\t_runtime.processNode(evt.detail.elt);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n}\n\n//====================================================================\n// API\n//====================================================================\n/** @type {HyperscriptObject} */\nexport default _hyperscript = mergeObjects(\n\tfunction (str, ctx) {\n\t\treturn _runtime.evaluate(str, ctx); //OK\n\t},\n\t{\n\t\tinternals: {\n\t\t\tlexer: _lexer,\n\t\t\tparser: _parser,\n\t\t\truntime: _runtime,\n\t\t},\n\t\tElementCollection: ElementCollection,\n\t\taddFeature: function (keyword, definition) {\n\t\t\t_parser.addFeature(keyword, definition);\n\t\t},\n\t\taddCommand: function (keyword, definition) {\n\t\t\t_parser.addCommand(keyword, definition);\n\t\t},\n\t\taddLeafExpression: function (name, definition) {\n\t\t\t_parser.addLeafExpression(name, definition);\n\t\t},\n\t\taddIndirectExpression: function (name, definition) {\n\t\t\t_parser.addIndirectExpression(name, definition);\n\t\t},\n\t\tevaluate: _runtime.evaluate.bind(_runtime),\n\t\tparse: _runtime.parse.bind(_runtime),\n\t\tprocessNode: _runtime.processNode.bind(_runtime),\n\t\tconfig: {\n\t\t\tattributes: \"_, script, data-script\",\n\t\t\tdefaultTransition: \"all 500ms ease-in\",\n\t\t\tdisableSelector: \"[disable-scripting], [data-disable-scripting]\",\n\t\t\tconversions: CONVERSIONS,\n\t\t},\n\t}\n);\n","///=========================================================================\n/// This module provides the core web functionality for hyperscript\n///=========================================================================\n\nimport { mergeObjects } from \"./utils.js\"\n\n/**\n * @param {HyperscriptObject} _hyperscript\n */\nexport default _hyperscript => {\n\t_hyperscript.addCommand(\"settle\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"settle\")) {\n\t\t\tif (!parser.commandBoundary(tokens.currentToken())) {\n\t\t\t\tvar onExpr = parser.requireElement(\"expression\", tokens);\n\t\t\t} else {\n\t\t\t\tvar onExpr = parser.requireElement(\"implicitMeTarget\", tokens);\n\t\t\t}\n\n\t\t\tvar settleCommand = {\n\t\t\t\ttype: \"settleCmd\",\n\t\t\t\targs: [onExpr],\n\t\t\t\top: function (context, on) {\n\t\t\t\t\truntime.nullCheck(on, onExpr);\n\t\t\t\t\tvar resolve = null;\n\t\t\t\t\tvar resolved = false;\n\t\t\t\t\tvar transitionStarted = false;\n\n\t\t\t\t\tvar promise = new Promise(function (r) {\n\t\t\t\t\t\tresolve = r;\n\t\t\t\t\t});\n\n\t\t\t\t\t// listen for a transition begin\n\t\t\t\t\ton.addEventListener(\n\t\t\t\t\t\t\"transitionstart\",\n\t\t\t\t\t\tfunction () {\n\t\t\t\t\t\t\ttransitionStarted = true;\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{ once: true }\n\t\t\t\t\t);\n\n\t\t\t\t\t// if no transition begins in 500ms, cancel\n\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\tif (!transitionStarted && !resolved) {\n\t\t\t\t\t\t\tresolve(runtime.findNext(settleCommand, context));\n\t\t\t\t\t\t}\n\t\t\t\t\t}, 500);\n\n\t\t\t\t\t// continue on a transition emd\n\t\t\t\t\ton.addEventListener(\n\t\t\t\t\t\t\"transitionend\",\n\t\t\t\t\t\tfunction () {\n\t\t\t\t\t\t\tif (!resolved) {\n\t\t\t\t\t\t\t\tresolve(runtime.findNext(settleCommand, context));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{ once: true }\n\t\t\t\t\t);\n\t\t\t\t\treturn promise;\n\t\t\t\t},\n\t\t\t\texecute: function (context) {\n\t\t\t\t\treturn runtime.unifiedExec(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t\treturn settleCommand;\n\t\t}\n\t});\n\n\t_hyperscript.addCommand(\"add\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"add\")) {\n\t\t\tvar classRef = parser.parseElement(\"classRef\", tokens);\n\t\t\tvar attributeRef = null;\n\t\t\tvar cssDeclaration = null;\n\t\t\tif (classRef == null) {\n\t\t\t\tattributeRef = parser.parseElement(\"attributeRef\", tokens);\n\t\t\t\tif (attributeRef == null) {\n\t\t\t\t\tcssDeclaration = parser.parseElement(\"styleLiteral\", tokens);\n\t\t\t\t\tif (cssDeclaration == null) {\n\t\t\t\t\t\tparser.raiseParseError(tokens, \"Expected either a class reference or attribute expression\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar classRefs = [classRef];\n\t\t\t\twhile ((classRef = parser.parseElement(\"classRef\", tokens))) {\n\t\t\t\t\tclassRefs.push(classRef);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (tokens.matchToken(\"to\")) {\n\t\t\t\tvar toExpr = parser.requireElement(\"expression\", tokens);\n\t\t\t} else {\n\t\t\t\tvar toExpr = parser.requireElement(\"implicitMeTarget\", tokens);\n\t\t\t}\n\n\t\t\tif (tokens.matchToken(\"when\")) {\n\t\t\t\tif (cssDeclaration) {\n\t\t\t\t\tparser.raiseParseError(tokens, \"Only class and properties are supported with a when clause\")\n\t\t\t\t}\n\t\t\t\tvar when = parser.requireElement(\"expression\", tokens);\n\t\t\t}\n\n\t\t\tif (classRefs) {\n\t\t\t\treturn {\n\t\t\t\t\tclassRefs: classRefs,\n\t\t\t\t\tto: toExpr,\n\t\t\t\t\targs: [toExpr, classRefs],\n\t\t\t\t\top: function (context, to, classRefs) {\n\t\t\t\t\t\truntime.nullCheck(to, toExpr);\n\t\t\t\t\t\truntime.forEach(classRefs, function (classRef) {\n\t\t\t\t\t\t\truntime.implicitLoop(to, function (target) {\n\t\t\t\t\t\t\t\tif (when) {\n\t\t\t\t\t\t\t\t\tcontext['result'] = target;\n\t\t\t\t\t\t\t\t\tlet whenResult = runtime.evaluateNoPromise(when, context);\n\t\t\t\t\t\t\t\t\tif (whenResult) {\n\t\t\t\t\t\t\t\t\t\tif (target instanceof Element) target.classList.add(classRef.className);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tif (target instanceof Element) target.classList.remove(classRef.className);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcontext['result'] = null;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tif (target instanceof Element) target.classList.add(classRef.className);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn runtime.findNext(this, context);\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t} else if (attributeRef) {\n\t\t\t\treturn {\n\t\t\t\t\ttype: \"addCmd\",\n\t\t\t\t\tattributeRef: attributeRef,\n\t\t\t\t\tto: toExpr,\n\t\t\t\t\targs: [toExpr],\n\t\t\t\t\top: function (context, to, attrRef) {\n\t\t\t\t\t\truntime.nullCheck(to, toExpr);\n\t\t\t\t\t\truntime.implicitLoop(to, function (target) {\n\t\t\t\t\t\t\tif (when) {\n\t\t\t\t\t\t\t\tcontext['result'] = target;\n\t\t\t\t\t\t\t\tlet whenResult = runtime.evaluateNoPromise(when, context);\n\t\t\t\t\t\t\t\tif (whenResult) {\n\t\t\t\t\t\t\t\t\ttarget.setAttribute(attributeRef.name, attributeRef.value);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ttarget.removeAttribute(attributeRef.name);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcontext['result'] = null;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttarget.setAttribute(attributeRef.name, attributeRef.value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn runtime.findNext(this, context);\n\t\t\t\t\t},\n\t\t\t\t\texecute: function (ctx) {\n\t\t\t\t\t\treturn runtime.unifiedExec(this, ctx);\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\treturn {\n\t\t\t\t\ttype: \"addCmd\",\n\t\t\t\t\tcssDeclaration: cssDeclaration,\n\t\t\t\t\tto: toExpr,\n\t\t\t\t\targs: [toExpr, cssDeclaration],\n\t\t\t\t\top: function (context, to, css) {\n\t\t\t\t\t\truntime.nullCheck(to, toExpr);\n\t\t\t\t\t\truntime.implicitLoop(to, function (target) {\n\t\t\t\t\t\t\ttarget.style.cssText += css;\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn runtime.findNext(this, context);\n\t\t\t\t\t},\n\t\t\t\t\texecute: function (ctx) {\n\t\t\t\t\t\treturn runtime.unifiedExec(this, ctx);\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t});\n\n\t_hyperscript.internals.parser.addGrammarElement(\"styleLiteral\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchOpToken(\"{\")) return;\n\n\t\tvar stringParts = [\"\"]\n\t\tvar exprs = []\n\n\t\twhile (tokens.hasMore()) {\n\t\t\tif (tokens.matchOpToken(\"\\\\\")) {\n\t\t\t\ttokens.consumeToken();\n\t\t\t} else if (tokens.matchOpToken(\"}\")) {\n\t\t\t\tbreak;\n\t\t\t} else if (tokens.matchToken(\"$\")) {\n\t\t\t\tvar opencurly = tokens.matchOpToken(\"{\");\n\t\t\t\tvar expr = parser.parseElement(\"expression\", tokens);\n\t\t\t\tif (opencurly) tokens.requireOpToken(\"}\");\n\n\t\t\t\texprs.push(expr)\n\t\t\t\tstringParts.push(\"\")\n\t\t\t} else {\n\t\t\t\tvar tok = tokens.consumeToken();\n\t\t\t\tstringParts[stringParts.length-1] += tokens.source.substring(tok.start, tok.end);\n\t\t\t}\n\n\t\t\tstringParts[stringParts.length-1] += tokens.lastWhitespace();\n\t\t}\n\n\t\treturn {\n\t\t\ttype: \"styleLiteral\",\n\t\t\targs: [exprs],\n\t\t\top: function (ctx, exprs) {\n\t\t\t\tvar rv = \"\";\n\n\t\t\t\tstringParts.forEach(function (part, idx) {\n\t\t\t\t\trv += part;\n\t\t\t\t\tif (idx in exprs) rv += exprs[idx];\n\t\t\t\t});\n\n\t\t\t\treturn rv;\n\t\t\t},\n\t\t\tevaluate: function(ctx) {\n\t\t\t\treturn runtime.unifiedEval(this, ctx);\n\t\t\t}\n\t\t}\n\t})\n\n\t_hyperscript.addCommand(\"remove\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"remove\")) {\n\t\t\tvar classRef = parser.parseElement(\"classRef\", tokens);\n\t\t\tvar attributeRef = null;\n\t\t\tvar elementExpr = null;\n\t\t\tif (classRef == null) {\n\t\t\t\tattributeRef = parser.parseElement(\"attributeRef\", tokens);\n\t\t\t\tif (attributeRef == null) {\n\t\t\t\t\telementExpr = parser.parseElement(\"expression\", tokens);\n\t\t\t\t\tif (elementExpr == null) {\n\t\t\t\t\t\tparser.raiseParseError(\n\t\t\t\t\t\t\ttokens,\n\t\t\t\t\t\t\t\"Expected either a class reference, attribute expression or value expression\"\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar classRefs = [classRef];\n\t\t\t\twhile ((classRef = parser.parseElement(\"classRef\", tokens))) {\n\t\t\t\t\tclassRefs.push(classRef);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (tokens.matchToken(\"from\")) {\n\t\t\t\tvar fromExpr = parser.requireElement(\"expression\", tokens);\n\t\t\t} else {\n\t\t\t\tvar fromExpr = parser.requireElement(\"implicitMeTarget\", tokens);\n\t\t\t}\n\n\t\t\tif (elementExpr) {\n\t\t\t\treturn {\n\t\t\t\t\telementExpr: elementExpr,\n\t\t\t\t\tfrom: fromExpr,\n\t\t\t\t\targs: [elementExpr],\n\t\t\t\t\top: function (context, element) {\n\t\t\t\t\t\truntime.nullCheck(element, elementExpr);\n\t\t\t\t\t\truntime.implicitLoop(element, function (target) {\n\t\t\t\t\t\t\tif (target.parentElement) {\n\t\t\t\t\t\t\t\ttarget.parentElement.removeChild(target);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn runtime.findNext(this, context);\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\treturn {\n\t\t\t\t\tclassRefs: classRefs,\n\t\t\t\t\tattributeRef: attributeRef,\n\t\t\t\t\telementExpr: elementExpr,\n\t\t\t\t\tfrom: fromExpr,\n\t\t\t\t\targs: [classRefs, fromExpr],\n\t\t\t\t\top: function (context, classRefs, from) {\n\t\t\t\t\t\truntime.nullCheck(from, fromExpr);\n\t\t\t\t\t\tif (classRefs) {\n\t\t\t\t\t\t\truntime.forEach(classRefs, function (classRef) {\n\t\t\t\t\t\t\t\truntime.implicitLoop(from, function (target) {\n\t\t\t\t\t\t\t\t\ttarget.classList.remove(classRef.className);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\truntime.implicitLoop(from, function (target) {\n\t\t\t\t\t\t\t\ttarget.removeAttribute(attributeRef.name);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn runtime.findNext(this, context);\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t});\n\n\t_hyperscript.addCommand(\"toggle\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"toggle\")) {\n\t\t\ttokens.matchAnyToken(\"the\", \"my\");\n\t\t\tif (tokens.currentToken().type === \"STYLE_REF\") {\n\t\t\t\tlet styleRef = tokens.consumeToken();\n\t\t\t\tvar name = styleRef.value.substr(1);\n\t\t\t\tvar visibility = true;\n\t\t\t\tvar hideShowStrategy = resolveStrategy(parser, tokens, name);\n\t\t\t\tif (tokens.matchToken(\"of\")) {\n\t\t\t\t\ttokens.pushFollow(\"with\");\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvar onExpr = parser.requireElement(\"expression\", tokens);\n\t\t\t\t\t} finally {\n\t\t\t\t\t\ttokens.popFollow();\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tvar onExpr = parser.requireElement(\"implicitMeTarget\", tokens);\n\t\t\t\t}\n\t\t\t} else if (tokens.matchToken(\"between\")) {\n\t\t\t\tvar between = true;\n\t\t\t\tvar classRef = parser.parseElement(\"classRef\", tokens);\n\t\t\t\ttokens.requireToken(\"and\");\n\t\t\t\tvar classRef2 = parser.requireElement(\"classRef\", tokens);\n\t\t\t} else {\n\t\t\t\tvar classRef = parser.parseElement(\"classRef\", tokens);\n\t\t\t\tvar attributeRef = null;\n\t\t\t\tif (classRef == null) {\n\t\t\t\t\tattributeRef = parser.parseElement(\"attributeRef\", tokens);\n\t\t\t\t\tif (attributeRef == null) {\n\t\t\t\t\t\tparser.raiseParseError(tokens, \"Expected either a class reference or attribute expression\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tvar classRefs = [classRef];\n\t\t\t\t\twhile ((classRef = parser.parseElement(\"classRef\", tokens))) {\n\t\t\t\t\t\tclassRefs.push(classRef);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (visibility !== true) {\n\t\t\t\tif (tokens.matchToken(\"on\")) {\n\t\t\t\t\tvar onExpr = parser.requireElement(\"expression\", tokens);\n\t\t\t\t} else {\n\t\t\t\t\tvar onExpr = parser.requireElement(\"implicitMeTarget\", tokens);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (tokens.matchToken(\"for\")) {\n\t\t\t\tvar time = parser.requireElement(\"expression\", tokens);\n\t\t\t} else if (tokens.matchToken(\"until\")) {\n\t\t\t\tvar evt = parser.requireElement(\"dotOrColonPath\", tokens, \"Expected event name\");\n\t\t\t\tif (tokens.matchToken(\"from\")) {\n\t\t\t\t\tvar from = parser.requireElement(\"expression\", tokens);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar toggleCmd = {\n\t\t\t\tclassRef: classRef,\n\t\t\t\tclassRef2: classRef2,\n\t\t\t\tclassRefs: classRefs,\n\t\t\t\tattributeRef: attributeRef,\n\t\t\t\ton: onExpr,\n\t\t\t\ttime: time,\n\t\t\t\tevt: evt,\n\t\t\t\tfrom: from,\n\t\t\t\ttoggle: function (on, classRef, classRef2, classRefs) {\n\t\t\t\t\truntime.nullCheck(on, onExpr);\n\t\t\t\t\tif (visibility) {\n\t\t\t\t\t\truntime.implicitLoop(on, function (target) {\n\t\t\t\t\t\t\thideShowStrategy(\"toggle\", target);\n\t\t\t\t\t\t});\n\t\t\t\t\t} else if (between) {\n\t\t\t\t\t\truntime.implicitLoop(on, function (target) {\n\t\t\t\t\t\t\tif (target.classList.contains(classRef.className)) {\n\t\t\t\t\t\t\t\ttarget.classList.remove(classRef.className);\n\t\t\t\t\t\t\t\ttarget.classList.add(classRef2.className);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttarget.classList.add(classRef.className);\n\t\t\t\t\t\t\t\ttarget.classList.remove(classRef2.className);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t} else if (classRefs) {\n\t\t\t\t\t\truntime.forEach(classRefs, function (classRef) {\n\t\t\t\t\t\t\truntime.implicitLoop(on, function (target) {\n\t\t\t\t\t\t\t\ttarget.classList.toggle(classRef.className);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\truntime.forEach(on, function (target) {\n\t\t\t\t\t\t\tif (target.hasAttribute(attributeRef.name)) {\n\t\t\t\t\t\t\t\ttarget.removeAttribute(attributeRef.name);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttarget.setAttribute(attributeRef.name, attributeRef.value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\targs: [onExpr, time, evt, from, classRef, classRef2, classRefs],\n\t\t\t\top: function (context, on, time, evt, from, classRef, classRef2, classRefs) {\n\t\t\t\t\tif (time) {\n\t\t\t\t\t\treturn new Promise(function (resolve) {\n\t\t\t\t\t\t\ttoggleCmd.toggle(on, classRef, classRef2, classRefs);\n\t\t\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\t\t\ttoggleCmd.toggle(on, classRef, classRef2, classRefs);\n\t\t\t\t\t\t\t\tresolve(runtime.findNext(toggleCmd, context));\n\t\t\t\t\t\t\t}, time);\n\t\t\t\t\t\t});\n\t\t\t\t\t} else if (evt) {\n\t\t\t\t\t\treturn new Promise(function (resolve) {\n\t\t\t\t\t\t\tvar target = from || context.me;\n\t\t\t\t\t\t\ttarget.addEventListener(\n\t\t\t\t\t\t\t\tevt,\n\t\t\t\t\t\t\t\tfunction () {\n\t\t\t\t\t\t\t\t\ttoggleCmd.toggle(on, classRef, classRef2, classRefs);\n\t\t\t\t\t\t\t\t\tresolve(runtime.findNext(toggleCmd, context));\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t{ once: true }\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\ttoggleCmd.toggle(on, classRef, classRef2, classRefs);\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.toggle(on, classRef, classRef2, classRefs);\n\t\t\t\t\t\treturn runtime.findNext(toggleCmd, context);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t};\n\t\t\treturn toggleCmd;\n\t\t}\n\t});\n\n\tvar HIDE_SHOW_STRATEGIES = {\n\t\tdisplay: function (op, element, arg) {\n\t\t\tif (arg) {\n\t\t\t\telement.style.display = arg;\n\t\t\t} else if (op === \"toggle\") {\n\t\t\t\tif (getComputedStyle(element).display === \"none\") {\n\t\t\t\t\tHIDE_SHOW_STRATEGIES.display(\"show\", element, arg);\n\t\t\t\t} else {\n\t\t\t\t\tHIDE_SHOW_STRATEGIES.display(\"hide\", element, arg);\n\t\t\t\t}\n\t\t\t} else if (op === \"hide\") {\n\t\t\t\tconst internalData = _hyperscript.internals.runtime.getInternalData(element);\n\t\t\t\tif (internalData.originalDisplay == null) {\n\t\t\t\t\tinternalData.originalDisplay = element.style.display;\n\t\t\t\t}\n\t\t\t\telement.style.display = \"none\";\n\t\t\t} else {\n\t\t\t\tconst internalData = _hyperscript.internals.runtime.getInternalData(element);\n\t\t\t\tif (internalData.originalDisplay && internalData.originalDisplay !== 'none') {\n\t\t\t\t\telement.style.display = internalData.originalDisplay;\n\t\t\t\t} else {\n\t\t\t\t\telement.style.removeProperty('display');\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tvisibility: function (op, element, arg) {\n\t\t\tif (arg) {\n\t\t\t\telement.style.visibility = arg;\n\t\t\t} else if (op === \"toggle\") {\n\t\t\t\tif (getComputedStyle(element).visibility === \"hidden\") {\n\t\t\t\t\tHIDE_SHOW_STRATEGIES.visibility(\"show\", element, arg);\n\t\t\t\t} else {\n\t\t\t\t\tHIDE_SHOW_STRATEGIES.visibility(\"hide\", element, arg);\n\t\t\t\t}\n\t\t\t} else if (op === \"hide\") {\n\t\t\t\telement.style.visibility = \"hidden\";\n\t\t\t} else {\n\t\t\t\telement.style.visibility = \"visible\";\n\t\t\t}\n\t\t},\n\t\topacity: function (op, element, arg) {\n\t\t\tif (arg) {\n\t\t\t\telement.style.opacity = arg;\n\t\t\t} else if (op === \"toggle\") {\n\t\t\t\tif (getComputedStyle(element).opacity === \"0\") {\n\t\t\t\t\tHIDE_SHOW_STRATEGIES.opacity(\"show\", element, arg);\n\t\t\t\t} else {\n\t\t\t\t\tHIDE_SHOW_STRATEGIES.opacity(\"hide\", element, arg);\n\t\t\t\t}\n\t\t\t} else if (op === \"hide\") {\n\t\t\t\telement.style.opacity = \"0\";\n\t\t\t} else {\n\t\t\t\telement.style.opacity = \"1\";\n\t\t\t}\n\t\t},\n\t};\n\n\tvar parseShowHideTarget = function (parser, runtime, tokens) {\n\t\tvar target;\n\t\tvar currentTokenValue = tokens.currentToken();\n\t\tif (currentTokenValue.value === \"when\" || currentTokenValue.value === \"with\" || parser.commandBoundary(currentTokenValue)) {\n\t\t\ttarget = parser.parseElement(\"implicitMeTarget\", tokens);\n\t\t} else {\n\t\t\ttarget = parser.parseElement(\"expression\", tokens);\n\t\t}\n\t\treturn target;\n\t};\n\n\tvar resolveStrategy = function (parser, tokens, name) {\n\t\tvar configDefault = _hyperscript.config.defaultHideShowStrategy;\n\t\tvar strategies = HIDE_SHOW_STRATEGIES;\n\t\tif (_hyperscript.config.hideShowStrategies) {\n\t\t\tstrategies = mergeObjects(strategies, _hyperscript.config.hideShowStrategies); // merge in user provided strategies\n\t\t}\n\t\tname = name || configDefault || \"display\";\n\t\tvar value = strategies[name];\n\t\tif (value == null) {\n\t\t\tparser.raiseParseError(tokens, \"Unknown show/hide strategy : \" + name);\n\t\t}\n\t\treturn value;\n\t};\n\n\t_hyperscript.addCommand(\"hide\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"hide\")) {\n\t\t\tvar targetExpr = parseShowHideTarget(parser, runtime, tokens);\n\n\t\t\tvar name = null;\n\t\t\tif (tokens.matchToken(\"with\")) {\n\t\t\t\tname = tokens.requireTokenType(\"IDENTIFIER\", \"STYLE_REF\").value;\n\t\t\t\tif (name.indexOf(\"*\") === 0) {\n\t\t\t\t\tname = name.substr(1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar hideShowStrategy = resolveStrategy(parser, tokens, name);\n\n\t\t\treturn {\n\t\t\t\ttarget: targetExpr,\n\t\t\t\targs: [targetExpr],\n\t\t\t\top: function (ctx, target) {\n\t\t\t\t\truntime.nullCheck(target, targetExpr);\n\t\t\t\t\truntime.implicitLoop(target, function (elt) {\n\t\t\t\t\t\thideShowStrategy(\"hide\", elt);\n\t\t\t\t\t});\n\t\t\t\t\treturn runtime.findNext(this, ctx);\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t});\n\n\t_hyperscript.addCommand(\"show\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"show\")) {\n\t\t\tvar targetExpr = parseShowHideTarget(parser, runtime, tokens);\n\n\t\t\tvar name = null;\n\t\t\tif (tokens.matchToken(\"with\")) {\n\t\t\t\tname = tokens.requireTokenType(\"IDENTIFIER\", \"STYLE_REF\").value;\n\t\t\t\tif (name.indexOf(\"*\") === 0) {\n\t\t\t\t\tname = name.substr(1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar arg = null;\n\t\t\tif (tokens.matchOpToken(\":\")) {\n\t\t\t\tvar tokenArr = tokens.consumeUntilWhitespace();\n\t\t\t\ttokens.matchTokenType(\"WHITESPACE\");\n\t\t\t\targ = tokenArr\n\t\t\t\t\t.map(function (t) {\n\t\t\t\t\t\treturn t.value;\n\t\t\t\t\t})\n\t\t\t\t\t.join(\"\");\n\t\t\t}\n\n\t\t\tif (tokens.matchToken(\"when\")) {\n\t\t\t\tvar when = parser.requireElement(\"expression\", tokens);\n\t\t\t}\n\n\t\t\tvar hideShowStrategy = resolveStrategy(parser, tokens, name);\n\n\t\t\treturn {\n\t\t\t\ttarget: targetExpr,\n\t\t\t\twhen: when,\n\t\t\t\targs: [targetExpr],\n\t\t\t\top: function (ctx, target) {\n\t\t\t\t\truntime.nullCheck(target, targetExpr);\n\t\t\t\t\truntime.implicitLoop(target, function (elt) {\n\t\t\t\t\t\tif (when) {\n\t\t\t\t\t\t\tctx['result'] = elt;\n\t\t\t\t\t\t\tlet whenResult = runtime.evaluateNoPromise(when, ctx);\n\t\t\t\t\t\t\tif (whenResult) {\n\t\t\t\t\t\t\t\thideShowStrategy(\"show\", elt, arg);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\thideShowStrategy(\"hide\", elt);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tctx['result'] = null;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\thideShowStrategy(\"show\", elt, arg);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\treturn runtime.findNext(this, ctx);\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t});\n\n\t_hyperscript.addCommand(\"take\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"take\")) {\n\t\t\tvar classRef = parser.requireElement(\"classRef\", tokens);\n\n\t\t\tif (tokens.matchToken(\"from\")) {\n\t\t\t\tvar fromExpr = parser.requireElement(\"expression\", tokens);\n\t\t\t} else {\n\t\t\t\tvar fromExpr = classRef;\n\t\t\t}\n\n\t\t\tif (tokens.matchToken(\"for\")) {\n\t\t\t\tvar forExpr = parser.requireElement(\"expression\", tokens);\n\t\t\t} else {\n\t\t\t\tvar forExpr = parser.requireElement(\"implicitMeTarget\", tokens);\n\t\t\t}\n\n\t\t\tvar takeCmd = {\n\t\t\t\tclassRef: classRef,\n\t\t\t\tfrom: fromExpr,\n\t\t\t\tforElt: forExpr,\n\t\t\t\targs: [classRef, fromExpr, forExpr],\n\t\t\t\top: function (context, eltColl, from, forElt) {\n\t\t\t\t\truntime.nullCheck(from, fromExpr);\n\t\t\t\t\truntime.nullCheck(forElt, forExpr);\n\t\t\t\t\tvar clazz = eltColl.className;\n\t\t\t\t\truntime.implicitLoop(from, function (target) {\n\t\t\t\t\t\ttarget.classList.remove(clazz);\n\t\t\t\t\t});\n\t\t\t\t\truntime.implicitLoop(forElt, function (target) {\n\t\t\t\t\t\ttarget.classList.add(clazz);\n\t\t\t\t\t});\n\t\t\t\t\treturn runtime.findNext(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t\treturn takeCmd;\n\t\t}\n\t});\n\n\tfunction putInto(runtime, context, prop, valueToPut) {\n\t\tif (prop != null) {\n\t\t\tvar value = runtime.resolveSymbol(prop, context);\n\t\t} else {\n\t\t\tvar value = context;\n\t\t}\n\t\tif (value instanceof Element || value instanceof HTMLDocument) {\n\t\t\twhile (value.firstChild) value.removeChild(value.firstChild);\n\t\t\tvalue.append(_hyperscript.internals.runtime.convertValue(valueToPut, \"Fragment\"));\n\t\t} else {\n\t\t\tif (prop != null) {\n\t\t\t\truntime.setSymbol(prop, context, null, valueToPut);\n\t\t\t} else {\n\t\t\t\tthrow \"Don't know how to put a value into \" + typeof context;\n\t\t\t}\n\t\t}\n\t}\n\n\t_hyperscript.addCommand(\"put\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"put\")) {\n\t\t\tvar value = parser.requireElement(\"expression\", tokens);\n\n\t\t\tvar operationToken = tokens.matchAnyToken(\"into\", \"before\", \"after\");\n\n\t\t\tif (operationToken == null && tokens.matchToken(\"at\")) {\n\t\t\t\ttokens.matchToken(\"the\"); // optional \"the\"\n\t\t\t\toperationToken = tokens.matchAnyToken(\"start\", \"end\");\n\t\t\t\ttokens.requireToken(\"of\");\n\t\t\t}\n\n\t\t\tif (operationToken == null) {\n\t\t\t\tparser.raiseParseError(tokens, \"Expected one of 'into', 'before', 'at start of', 'at end of', 'after'\");\n\t\t\t}\n\t\t\tvar target = parser.requireElement(\"expression\", tokens);\n\n\t\t\tvar operation = operationToken.value;\n\n\t\t\tvar arrayIndex = false;\n\t\t\tvar symbolWrite = false;\n\t\t\tvar rootExpr = null;\n\t\t\tvar prop = null;\n\n\t\t\tif (target.type === \"arrayIndex\" && operation === \"into\") {\n\t\t\t\tarrayIndex = true;\n\t\t\t\tprop = target.prop;\n\t\t\t\trootExpr = target.root;\n\t\t\t}  else if (target.prop && target.root && operation === \"into\") {\n\t\t\t\tprop = target.prop.value;\n\t\t\t\trootExpr = target.root;\n\t\t\t} else if (target.type === \"symbol\" && operation === \"into\") {\n\t\t\t\tsymbolWrite = true;\n\t\t\t\tprop = target.name;\n\t\t\t} else if (target.type === \"attributeRef\" && operation === \"into\") {\n\t\t\t\tvar attributeWrite = true;\n\t\t\t\tprop = target.name;\n\t\t\t\trootExpr = parser.requireElement(\"implicitMeTarget\", tokens);\n\t\t\t} else if (target.type === \"styleRef\" && operation === \"into\") {\n\t\t\t\tvar styleWrite = true;\n\t\t\t\tprop = target.name;\n\t\t\t\trootExpr = parser.requireElement(\"implicitMeTarget\", tokens);\n\t\t\t} else if (target.attribute && operation === \"into\") {\n\t\t\t\tvar attributeWrite = target.attribute.type === \"attributeRef\";\n\t\t\t\tvar styleWrite = target.attribute.type === \"styleRef\";\n\t\t\t\tprop = target.attribute.name;\n\t\t\t\trootExpr = target.root;\n\t\t\t} else {\n\t\t\t\trootExpr = target;\n\t\t\t}\n\n\t\t\tvar putCmd = {\n\t\t\t\ttarget: target,\n\t\t\t\toperation: operation,\n\t\t\t\tsymbolWrite: symbolWrite,\n\t\t\t\tvalue: value,\n\t\t\t\targs: [rootExpr, prop, value],\n\t\t\t\top: function (context, root, prop, valueToPut) {\n\t\t\t\t\tif (symbolWrite) {\n\t\t\t\t\t\tputInto(runtime, context, prop, valueToPut);\n\t\t\t\t\t} else {\n\t\t\t\t\t\truntime.nullCheck(root, rootExpr);\n\t\t\t\t\t\tif (operation === \"into\") {\n\t\t\t\t\t\t\tif (attributeWrite) {\n\t\t\t\t\t\t\t\truntime.implicitLoop(root, function (elt) {\n\t\t\t\t\t\t\t\t\telt.setAttribute(prop, valueToPut);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t} else if (styleWrite) {\n\t\t\t\t\t\t\t\truntime.implicitLoop(root, function (elt) {\n\t\t\t\t\t\t\t\t\telt.style[prop] = valueToPut;\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t} else if (arrayIndex) {\n\t\t\t\t\t\t\t\troot[prop] = valueToPut;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\truntime.implicitLoop(root, function (elt) {\n\t\t\t\t\t\t\t\t\tputInto(runtime, elt, prop, valueToPut);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvar op =\n\t\t\t\t\t\t\t\toperation === \"before\"\n\t\t\t\t\t\t\t\t\t? Element.prototype.before\n\t\t\t\t\t\t\t\t\t: operation === \"after\"\n\t\t\t\t\t\t\t\t\t? Element.prototype.after\n\t\t\t\t\t\t\t\t\t: operation === \"start\"\n\t\t\t\t\t\t\t\t\t? Element.prototype.prepend\n\t\t\t\t\t\t\t\t\t: operation === \"end\"\n\t\t\t\t\t\t\t\t\t? Element.prototype.append\n\t\t\t\t\t\t\t\t\t: Element.prototype.append; // unreachable\n\n\t\t\t\t\t\t\truntime.implicitLoop(root, function (elt) {\n\t\t\t\t\t\t\t\top.call(\n\t\t\t\t\t\t\t\t\telt,\n\t\t\t\t\t\t\t\t\tvalueToPut instanceof Node\n\t\t\t\t\t\t\t\t\t\t? valueToPut\n\t\t\t\t\t\t\t\t\t\t: runtime.convertValue(valueToPut, \"Fragment\")\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn runtime.findNext(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t\treturn putCmd;\n\t\t}\n\t});\n\n\tfunction parsePseudopossessiveTarget(parser, runtime, tokens) {\n\t\tvar targets;\n\t\tif (\n\t\t\ttokens.matchToken(\"the\") ||\n\t\t\ttokens.matchToken(\"element\") ||\n\t\t\ttokens.matchToken(\"elements\") ||\n\t\t\ttokens.currentToken().type === \"CLASS_REF\" ||\n\t\t\ttokens.currentToken().type === \"ID_REF\" ||\n\t\t\t(tokens.currentToken().op && tokens.currentToken().value === \"<\")\n\t\t) {\n\t\t\tparser.possessivesDisabled = true;\n\t\t\ttry {\n\t\t\t\ttargets = parser.parseElement(\"expression\", tokens);\n\t\t\t} finally {\n\t\t\t\tdelete parser.possessivesDisabled;\n\t\t\t}\n\t\t\t// optional possessive\n\t\t\tif (tokens.matchOpToken(\"'\")) {\n\t\t\t\ttokens.requireToken(\"s\");\n\t\t\t}\n\t\t} else if (tokens.currentToken().type === \"IDENTIFIER\" && tokens.currentToken().value === \"its\") {\n\t\t\tvar identifier = tokens.matchToken(\"its\");\n\t\t\ttargets = {\n\t\t\t\ttype: \"pseudopossessiveIts\",\n\t\t\t\ttoken: identifier,\n\t\t\t\tname: identifier.value,\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn runtime.resolveSymbol(\"it\", context);\n\t\t\t\t},\n\t\t\t};\n\t\t} else {\n\t\t\ttokens.matchToken(\"my\") || tokens.matchToken(\"me\"); // consume optional 'my'\n\t\t\ttargets = parser.parseElement(\"implicitMeTarget\", tokens);\n\t\t}\n\t\treturn targets;\n\t}\n\n\t_hyperscript.addCommand(\"transition\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"transition\")) {\n\t\t\tvar targetsExpr = parsePseudopossessiveTarget(parser, runtime, tokens);\n\n\t\t\tvar properties = [];\n\t\t\tvar from = [];\n\t\t\tvar to = [];\n\t\t\tvar currentToken = tokens.currentToken();\n\t\t\twhile (\n\t\t\t\t!parser.commandBoundary(currentToken) &&\n\t\t\t\tcurrentToken.value !== \"over\" &&\n\t\t\t\tcurrentToken.value !== \"using\"\n\t\t\t) {\n\t\t\t\tif (tokens.currentToken().type === \"STYLE_REF\") {\n\t\t\t\t\tlet styleRef = tokens.consumeToken();\n\t\t\t\t\tlet styleProp = styleRef.value.substr(1);\n\t\t\t\t\tproperties.push({\n\t\t\t\t\t\ttype: \"styleRefValue\",\n\t\t\t\t\t\tevaluate: function () {\n\t\t\t\t\t\t\treturn styleProp;\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tproperties.push(parser.requireElement(\"stringLike\", tokens));\n\t\t\t\t}\n\n\t\t\t\tif (tokens.matchToken(\"from\")) {\n\t\t\t\t\tfrom.push(parser.requireElement(\"expression\", tokens));\n\t\t\t\t} else {\n\t\t\t\t\tfrom.push(null);\n\t\t\t\t}\n\t\t\t\ttokens.requireToken(\"to\");\n\t\t\t\tif (tokens.matchToken(\"initial\")) {\n\t\t\t\t\tto.push({\n\t\t\t\t\t\ttype: \"initial_literal\",\n\t\t\t\t\t\tevaluate : function(){\n\t\t\t\t\t\t\treturn \"initial\";\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tto.push(parser.requireElement(\"expression\", tokens));\n\t\t\t\t}\n\t\t\t\tcurrentToken = tokens.currentToken();\n\t\t\t}\n\t\t\tif (tokens.matchToken(\"over\")) {\n\t\t\t\tvar over = parser.requireElement(\"expression\", tokens);\n\t\t\t} else if (tokens.matchToken(\"using\")) {\n\t\t\t\tvar using = parser.requireElement(\"expression\", tokens);\n\t\t\t}\n\n\t\t\tvar transition = {\n\t\t\t\tto: to,\n\t\t\t\targs: [targetsExpr, properties, from, to, using, over],\n\t\t\t\top: function (context, targets, properties, from, to, using, over) {\n\t\t\t\t\truntime.nullCheck(targets, targetsExpr);\n\t\t\t\t\tvar promises = [];\n\t\t\t\t\truntime.implicitLoop(targets, function (target) {\n\t\t\t\t\t\tvar promise = new Promise(function (resolve, reject) {\n\t\t\t\t\t\t\tvar initialTransition = target.style.transition;\n\t\t\t\t\t\t\tif (over) {\n\t\t\t\t\t\t\t\ttarget.style.transition = \"all \" + over + \"ms ease-in\";\n\t\t\t\t\t\t\t} else if (using) {\n\t\t\t\t\t\t\t\ttarget.style.transition = using;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttarget.style.transition = _hyperscript.config.defaultTransition;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvar internalData = runtime.getInternalData(target);\n\t\t\t\t\t\t\tvar computedStyles = getComputedStyle(target);\n\n\t\t\t\t\t\t\tvar initialStyles = {};\n\t\t\t\t\t\t\tfor (var i = 0; i < computedStyles.length; i++) {\n\t\t\t\t\t\t\t\tvar name = computedStyles[i];\n\t\t\t\t\t\t\t\tvar initialValue = computedStyles[name];\n\t\t\t\t\t\t\t\tinitialStyles[name] = initialValue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// store intitial values\n\t\t\t\t\t\t\tif (!internalData.initalStyles) {\n\t\t\t\t\t\t\t\tinternalData.initalStyles = initialStyles;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfor (var i = 0; i < properties.length; i++) {\n\t\t\t\t\t\t\t\tvar property = properties[i];\n\t\t\t\t\t\t\t\tvar fromVal = from[i];\n\t\t\t\t\t\t\t\tif (fromVal === \"computed\" || fromVal == null) {\n\t\t\t\t\t\t\t\t\ttarget.style[property] = initialStyles[property];\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ttarget.style[property] = fromVal;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//console.log(\"transition started\", transition);\n\n\t\t\t\t\t\t\tvar transitionStarted = false;\n\t\t\t\t\t\t\tvar resolved = false;\n\n\t\t\t\t\t\t\ttarget.addEventListener(\n\t\t\t\t\t\t\t\t\"transitionend\",\n\t\t\t\t\t\t\t\tfunction () {\n\t\t\t\t\t\t\t\t\tif (!resolved) {\n\t\t\t\t\t\t\t\t\t\t//console.log(\"transition ended\", transition);\n\t\t\t\t\t\t\t\t\t\ttarget.style.transition = initialTransition;\n\t\t\t\t\t\t\t\t\t\tresolved = true;\n\t\t\t\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t{ once: true }\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\ttarget.addEventListener(\n\t\t\t\t\t\t\t\t\"transitionstart\",\n\t\t\t\t\t\t\t\tfunction () {\n\t\t\t\t\t\t\t\t\ttransitionStarted = true;\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t{ once: true }\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// it no transition has started in 100ms, continue\n\t\t\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\t\t\tif (!resolved && !transitionStarted) {\n\t\t\t\t\t\t\t\t\t//console.log(\"transition ended\", transition);\n\t\t\t\t\t\t\t\t\ttarget.style.transition = initialTransition;\n\t\t\t\t\t\t\t\t\tresolved = true;\n\t\t\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}, 100);\n\n\t\t\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\t\t\tvar autoProps = [];\n\t\t\t\t\t\t\t\tfor (var i = 0; i < properties.length; i++) {\n\t\t\t\t\t\t\t\t\tvar property = properties[i];\n\t\t\t\t\t\t\t\t\tvar toVal = to[i];\n\t\t\t\t\t\t\t\t\tif (toVal === \"initial\") {\n\t\t\t\t\t\t\t\t\t\tvar propertyValue = internalData.initalStyles[property];\n\t\t\t\t\t\t\t\t\t\ttarget.style[property] = propertyValue;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\ttarget.style[property] = toVal;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t//console.log(\"set\", property, \"to\", target.style[property], \"on\", target, \"value passed in : \", toVal);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}, 0);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tpromises.push(promise);\n\t\t\t\t\t});\n\t\t\t\t\treturn Promise.all(promises).then(function () {\n\t\t\t\t\t\treturn runtime.findNext(transition, context);\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t};\n\t\t\treturn transition;\n\t\t}\n\t});\n\n\t_hyperscript.addCommand(\"measure\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"measure\")) return;\n\n\t\tvar targetExpr = parsePseudopossessiveTarget(parser, runtime, tokens);\n\n\t\tvar propsToMeasure = [];\n\t\tif (!parser.commandBoundary(tokens.currentToken()))\n\t\t\tdo {\n\t\t\t\tpropsToMeasure.push(tokens.matchTokenType(\"IDENTIFIER\").value);\n\t\t\t} while (tokens.matchOpToken(\",\"));\n\n\t\treturn {\n\t\t\tproperties: propsToMeasure,\n\t\t\targs: [targetExpr],\n\t\t\top: function (ctx, target) {\n\t\t\t\truntime.nullCheck(target, targetExpr);\n\t\t\t\tif (0 in target) target = target[0]; // not measuring multiple elts\n\t\t\t\tvar rect = target.getBoundingClientRect();\n\t\t\t\tvar scroll = {\n\t\t\t\t\ttop: target.scrollTop,\n\t\t\t\t\tleft: target.scrollLeft,\n\t\t\t\t\ttopMax: target.scrollTopMax,\n\t\t\t\t\tleftMax: target.scrollLeftMax,\n\t\t\t\t\theight: target.scrollHeight,\n\t\t\t\t\twidth: target.scrollWidth,\n\t\t\t\t};\n\n\t\t\t\tctx.result = {\n\t\t\t\t\tx: rect.x,\n\t\t\t\t\ty: rect.y,\n\t\t\t\t\tleft: rect.left,\n\t\t\t\t\ttop: rect.top,\n\t\t\t\t\tright: rect.right,\n\t\t\t\t\tbottom: rect.bottom,\n\t\t\t\t\twidth: rect.width,\n\t\t\t\t\theight: rect.height,\n\t\t\t\t\tbounds: rect,\n\n\t\t\t\t\tscrollLeft: scroll.left,\n\t\t\t\t\tscrollTop: scroll.top,\n\t\t\t\t\tscrollLeftMax: scroll.leftMax,\n\t\t\t\t\tscrollTopMax: scroll.topMax,\n\t\t\t\t\tscrollWidth: scroll.width,\n\t\t\t\t\tscrollHeight: scroll.height,\n\t\t\t\t\tscroll: scroll,\n\t\t\t\t};\n\n\t\t\t\truntime.forEach(propsToMeasure, function (prop) {\n\t\t\t\t\tif (prop in ctx.result) ctx[prop] = ctx.result[prop];\n\t\t\t\t\telse throw \"No such measurement as \" + prop;\n\t\t\t\t});\n\n\t\t\t\treturn runtime.findNext(this, ctx);\n\t\t\t},\n\t\t};\n\t});\n\n\t_hyperscript.addLeafExpression(\"closestExpr\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"closest\")) {\n\t\t\tif (tokens.matchToken(\"parent\")) {\n\t\t\t\tvar parentSearch = true;\n\t\t\t}\n\n\t\t\tvar css = null;\n\t\t\tif (tokens.currentToken().type === \"ATTRIBUTE_REF\") {\n\t\t\t\tvar attributeRef = parser.requireElement(\"attributeRefAccess\", tokens, null);\n\t\t\t\tcss = \"[\" + attributeRef.attribute.name + \"]\";\n\t\t\t}\n\n\t\t\tif (css == null) {\n\t\t\t\tvar expr = parser.requireElement(\"expression\", tokens);\n\t\t\t\tif (expr.css == null) {\n\t\t\t\t\tparser.raiseParseError(tokens, \"Expected a CSS expression\");\n\t\t\t\t} else {\n\t\t\t\t\tcss = expr.css;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (tokens.matchToken(\"to\")) {\n\t\t\t\tvar to = parser.parseElement(\"expression\", tokens);\n\t\t\t} else {\n\t\t\t\tvar to = parser.parseElement(\"implicitMeTarget\", tokens);\n\t\t\t}\n\n\t\t\tvar closestExpr = {\n\t\t\t\ttype: \"closestExpr\",\n\t\t\t\tparentSearch: parentSearch,\n\t\t\t\texpr: expr,\n\t\t\t\tcss: css,\n\t\t\t\tto: to,\n\t\t\t\targs: [to],\n\t\t\t\top: function (ctx, to) {\n\t\t\t\t\tif (to == null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlet result = [];\n\t\t\t\t\t\truntime.implicitLoop(to, function(to){\n\t\t\t\t\t\t\tif (parentSearch) {\n\t\t\t\t\t\t\t\tresult.push(to.parentElement ? to.parentElement.closest(css) : null);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tresult.push(to.closest(css));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t\tif (runtime.shouldAutoIterate(to)) {\n\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn result[0];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t\t},\n\t\t\t};\n\n\t\t\tif (attributeRef) {\n\t\t\t\tattributeRef.root = closestExpr;\n\t\t\t\tattributeRef.args = [closestExpr];\n\t\t\t\treturn attributeRef;\n\t\t\t} else {\n\t\t\t\treturn closestExpr;\n\t\t\t}\n\t\t}\n\t});\n\n\t_hyperscript.addCommand(\"go\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"go\")) {\n\t\t\tif (tokens.matchToken(\"back\")) {\n\t\t\t\tvar back = true;\n\t\t\t} else {\n\t\t\t\ttokens.matchToken(\"to\");\n\t\t\t\tif (tokens.matchToken(\"url\")) {\n\t\t\t\t\tvar target = parser.requireElement(\"stringLike\", tokens);\n\t\t\t\t\tvar url = true;\n\t\t\t\t\tif (tokens.matchToken(\"in\")) {\n\t\t\t\t\t\ttokens.requireToken(\"new\");\n\t\t\t\t\t\ttokens.requireToken(\"window\");\n\t\t\t\t\t\tvar newWindow = true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttokens.matchToken(\"the\"); // optional the\n\t\t\t\t\tvar verticalPosition = tokens.matchAnyToken(\"top\", \"middle\", \"bottom\");\n\t\t\t\t\tvar horizontalPosition = tokens.matchAnyToken(\"left\", \"center\", \"right\");\n\t\t\t\t\tif (verticalPosition || horizontalPosition) {\n\t\t\t\t\t\ttokens.requireToken(\"of\");\n\t\t\t\t\t}\n\t\t\t\t\tvar target = parser.requireElement(\"unaryExpression\", tokens);\n\n\t\t\t\t\tvar plusOrMinus = tokens.matchAnyOpToken(\"+\", \"-\");\n\t\t\t\t\tif (plusOrMinus) {\n\t\t\t\t\t\ttokens.pushFollow(\"px\");\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tvar offset = parser.requireElement(\"expression\", tokens);\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\ttokens.popFollow();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ttokens.matchToken(\"px\"); // optional px\n\n\t\t\t\t\tvar smoothness = tokens.matchAnyToken(\"smoothly\", \"instantly\");\n\n\t\t\t\t\tvar scrollOptions = {};\n\t\t\t\t\tif (verticalPosition) {\n\t\t\t\t\t\tif (verticalPosition.value === \"top\") {\n\t\t\t\t\t\t\tscrollOptions.block = \"start\";\n\t\t\t\t\t\t} else if (verticalPosition.value === \"bottom\") {\n\t\t\t\t\t\t\tscrollOptions.block = \"end\";\n\t\t\t\t\t\t} else if (verticalPosition.value === \"middle\") {\n\t\t\t\t\t\t\tscrollOptions.block = \"center\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (horizontalPosition) {\n\t\t\t\t\t\tif (horizontalPosition.value === \"left\") {\n\t\t\t\t\t\t\tscrollOptions.inline = \"start\";\n\t\t\t\t\t\t} else if (horizontalPosition.value === \"center\") {\n\t\t\t\t\t\t\tscrollOptions.inline = \"center\";\n\t\t\t\t\t\t} else if (horizontalPosition.value === \"right\") {\n\t\t\t\t\t\t\tscrollOptions.inline = \"end\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (smoothness) {\n\t\t\t\t\t\tif (smoothness.value === \"smoothly\") {\n\t\t\t\t\t\t\tscrollOptions.behavior = \"smooth\";\n\t\t\t\t\t\t} else if (smoothness.value === \"instantly\") {\n\t\t\t\t\t\t\tscrollOptions.behavior = \"instant\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar goCmd = {\n\t\t\t\ttarget: target,\n\t\t\t\targs: [target, offset],\n\t\t\t\top: function (ctx, to, offset) {\n\t\t\t\t\tif (back) {\n\t\t\t\t\t\twindow.history.back();\n\t\t\t\t\t} else if (url) {\n\t\t\t\t\t\tif (to) {\n\t\t\t\t\t\t\tif (newWindow) {\n\t\t\t\t\t\t\t\twindow.open(to);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\twindow.location.href = to;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\truntime.implicitLoop(to, function (target) {\n\n\t\t\t\t\t\t\tif (target === window) {\n\t\t\t\t\t\t\t\ttarget = document.body;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif(plusOrMinus) {\n\t\t\t\t\t\t\t\t// a top scroll w/ an offset of some sort\n\t\t\t\t\t\t\t\tvar boundingRect = target.getBoundingClientRect();\n\t\t\t\t\t\t\t\tlet scrollShim = document.createElement('div');\n\n\t\t\t\t\t\t\t\tif (plusOrMinus.value === \"-\") {\n\t\t\t\t\t\t\t\t\tvar finalOffset = -offset;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tvar finalOffset = offset;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tscrollShim.style.position = 'absolute';\n\t\t\t\t\t\t\t\tscrollShim.style.top = (boundingRect.x + finalOffset) + \"px\";\n\t\t\t\t\t\t\t\tscrollShim.style.left = (boundingRect.y + finalOffset) + \"px\";\n\t\t\t\t\t\t\t\tscrollShim.style.height = (boundingRect.height + (2 * finalOffset)) + \"px\";\n\t\t\t\t\t\t\t\tscrollShim.style.width = (boundingRect.width + (2 * finalOffset)) + \"px\";\n\t\t\t\t\t\t\t\tscrollShim.style.zIndex = \"\" + Number.MIN_SAFE_INTEGER;\n\t\t\t\t\t\t\t\tscrollShim.style.opacity = \"0\";\n\n\t\t\t\t\t\t\t\tdocument.body.appendChild(scrollShim);\n\t\t\t\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\t\t\t\tdocument.body.removeChild(scrollShim);\n\t\t\t\t\t\t\t\t}, 100);\n\n\t\t\t\t\t\t\t\ttarget = scrollShim;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\ttarget.scrollIntoView(scrollOptions);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\treturn runtime.findNext(goCmd, ctx);\n\t\t\t\t},\n\t\t\t};\n\t\t\treturn goCmd;\n\t\t}\n\t});\n\n\t_hyperscript.config.conversions.dynamicResolvers.push(function (str, node) {\n\t\tif (!(str === \"Values\" || str.indexOf(\"Values:\") === 0)) {\n\t\t\treturn;\n\t\t}\n\t\tvar conversion = str.split(\":\")[1];\n\t\t/** @type Object<string,string | string[]> */\n\t\tvar result = {};\n\n\t\tvar implicitLoop = _hyperscript.internals.runtime.implicitLoop;\n\n\t\timplicitLoop(node, function (/** @type HTMLInputElement */ node) {\n\t\t\t// Try to get a value directly from this node\n\t\t\tvar input = getInputInfo(node);\n\n\t\t\tif (input !== undefined) {\n\t\t\t\tresult[input.name] = input.value;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Otherwise, try to query all child elements of this node that *should* contain values.\n\t\t\tif (node.querySelectorAll != undefined) {\n\t\t\t\tvar children = node.querySelectorAll(\"input,select,textarea\");\n\t\t\t\tchildren.forEach(appendValue);\n\t\t\t}\n\t\t});\n\n\t\tif (conversion) {\n\t\t\tif (conversion === \"JSON\") {\n\t\t\t\treturn JSON.stringify(result);\n\t\t\t} else if (conversion === \"Form\") {\n\t\t\t\treturn new URLSearchParams(result).toString();\n\t\t\t} else {\n\t\t\t\tthrow \"Unknown conversion: \" + conversion;\n\t\t\t}\n\t\t} else {\n\t\t\treturn result;\n\t\t}\n\n\t\t/**\n\t\t * @param {HTMLInputElement} node\n\t\t */\n\t\tfunction appendValue(node) {\n\t\t\tvar info = getInputInfo(node);\n\n\t\t\tif (info == undefined) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If there is no value already stored in this space.\n\t\t\tif (result[info.name] == undefined) {\n\t\t\t\tresult[info.name] = info.value;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (Array.isArray(result[info.name]) && Array.isArray(info.value)) {\n\t\t\t\tresult[info.name] = [].concat(result[info.name], info.value);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @param {HTMLInputElement} node\n\t\t * @returns {{name:string, value:string | string[]} | undefined}\n\t\t */\n\t\tfunction getInputInfo(node) {\n\t\t\ttry {\n\t\t\t\t/** @type {{name: string, value: string | string[]}}*/\n\t\t\t\tvar result = {\n\t\t\t\t\tname: node.name,\n\t\t\t\t\tvalue: node.value,\n\t\t\t\t};\n\n\t\t\t\tif (result.name == undefined || result.value == undefined) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\tif (node.type == \"radio\" && node.checked == false) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\tif (node.type == \"checkbox\") {\n\t\t\t\t\tif (node.checked == false) {\n\t\t\t\t\t\tresult.value = undefined;\n\t\t\t\t\t} else if (typeof result.value === \"string\") {\n\t\t\t\t\t\tresult.value = [result.value];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (node.type == \"select-multiple\") {\n\t\t\t\t\t/** @type {NodeListOf<HTMLSelectElement>} */\n\t\t\t\t\tvar selected = node.querySelectorAll(\"option[selected]\");\n\n\t\t\t\t\tresult.value = [];\n\t\t\t\t\tfor (var index = 0; index < selected.length; index++) {\n\t\t\t\t\t\tresult.value.push(selected[index].value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} catch (e) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t}\n\t});\n\n\t_hyperscript.config.conversions[\"HTML\"] = function (value) {\n\t\tvar toHTML = /** @returns {string}*/ function (/** @type any*/ value) {\n\t\t\tif (value instanceof Array) {\n\t\t\t\treturn value\n\t\t\t\t\t.map(function (item) {\n\t\t\t\t\t\treturn toHTML(item);\n\t\t\t\t\t})\n\t\t\t\t\t.join(\"\");\n\t\t\t}\n\n\t\t\tif (value instanceof HTMLElement) {\n\t\t\t\treturn value.outerHTML;\n\t\t\t}\n\n\t\t\tif (value instanceof NodeList) {\n\t\t\t\tvar result = \"\";\n\t\t\t\tfor (var i = 0; i < value.length; i++) {\n\t\t\t\t\tvar node = value[i];\n\t\t\t\t\tif (node instanceof HTMLElement) {\n\t\t\t\t\t\tresult += node.outerHTML;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tif (value.toString) {\n\t\t\t\treturn value.toString();\n\t\t\t}\n\n\t\t\treturn \"\";\n\t\t};\n\n\t\treturn toHTML(value);\n\t};\n\n\t_hyperscript.config.conversions[\"Fragment\"] = function (val) {\n\t\tvar frag = document.createDocumentFragment();\n\t\t_hyperscript.internals.runtime.implicitLoop(val, function (val) {\n\t\t\tif (val instanceof Node) frag.append(val);\n\t\t\telse {\n\t\t\t\tvar temp = document.createElement(\"template\");\n\t\t\t\ttemp.innerHTML = val;\n\t\t\t\tfrag.append(temp.content);\n\t\t\t}\n\t\t});\n\t\treturn frag;\n\t};\n}\n","\nimport _hyperscript from \"../lib/core.js\"\n\nimport web from \"../lib/web.js\"\n\nweb(_hyperscript)\n\nexport default _hyperscript\n"],"names":["mergeObjects","obj1","obj2","key","hasOwnProperty","getOrInitObject","root","prop","value","newObj","varargConstructor","Cls","args","bind","apply","concat","_hyperscript","globalScope","globalThis","ElementCollection","css","relativeToElement","escape","this","_css","contains","elt","selectMatches","Symbol","iterator","_runtime","getRootNode","querySelectorAll","escapeSelector","substr","className","length","_lexer","OP_TABLE","$","isValidCSSClassChar","c","isAlpha","isNumeric","isValidCSSIDChar","isWhitespace","isNewline","isIdentifierChar","dollarIsOp","makeTokensObject","tokens","consumed","source","consumeWhitespace","_lastConsumed","token","type","push","shift","raiseError","error","_parser","raiseParseError","matchOpToken","currentToken","op","consumeToken","matchTokenType","type1","type2","type3","type4","indexOf","matchToken","follows","match","consumeUntil","tokenList","n","dontIgnoreWhitespace","i","pushFollow","str","popFollow","pop","clearFollow","tmp","restoreFollow","f","matchAnyToken","op1","op2","op3","arguments","opToken","matchAnyOpToken","requireOpToken","requireTokenType","JSON","stringify","peekToken","peek","requireToken","list","hasMore","lastMatch","consumeUntilWhitespace","lastWhitespace","sourceFor","substring","startToken","start","endToken","end","lineFor","split","line","isValidSingleQuoteStringStart","previousToken","tokenize","string","template","position","column","lastToken","templateBraceCount","inTemplate","currentChar","nextChar","charAfterThat","possiblePrecedingSymbol","consumeAttributeReference","consumeShortAttributeReference","consumeStyleReference","consumeIdentifier","consumeNumber","consumeOp","makeToken","consumeChar","Error","consumeString","consumeIdReference","consumeClassReference","consumeComment","classRef","attributeRef","styleRef","idRef","identifier","number","makeOpToken","startChar","charAt","whitespace","GRAMMAR","COMMANDS","FEATURES","LEAF_EXPRESSIONS","INDIRECT_EXPRESSIONS","initElt","parseElement","programSource","undefined","elementDefinition","requireElement","message","result","parseAnyOf","types","expression","addGrammarElement","name","definition","lines","contextLine","repeat","createParserContext","commandStart","featureStart","parser","runtime","featureElement","featureDefinition","commandElement","commandDefinition","cmd","next","indirect","unless","context","conditional","execute","unifiedExec","parent","leaf","setParent","children","Set","add","commandBoundary","parseHyperScript","addCommand","keyword","commandGrammarType","commandDefinitionWrapper","meta","command","addFeature","featureGrammarType","featureDefinitionWrapper","isFeature","addLeafExpression","addIndirectExpression","parseStringTemplate","returnArr","startingBrace","ensureTerminated","commandList","implicitReturn","returned","resolve","HALT","ctx","CONVERSIONS","dynamicResolvers","Number","toFixed","num","parseInt","String","val","toString","Int","Float","parseFloat","Date","Array","from","Object","parse","matchesSelector","selector","matchesFunction","matches","msMatchesSelector","mozMatchesSelector","webkitMatchesSelector","oMatchesSelector","call","triggerEvent","eventName","detail","sender","event","evt","Event","bubbles","cancelable","document","createEvent","initCustomEvent","makeEvent","dispatchEvent","isArrayLike","isArray","NodeList","HTMLCollection","shouldAutoIterate","forEach","func","isIterable","unwrapAsyncs","values","asyncWrapper","j","valueElement","unifiedEval","async","wrappedAsyncs","argument","arr","element","evaluate","then","Promise","reject","arg","all","wrapArrays","e","reason","_scriptAttrs","getScriptAttributes","config","attributes","replace","getScript","scriptAttribute","hasAttribute","getAttribute","HTMLScriptElement","innerText","hyperscriptFeaturesMap","WeakMap","getHyperscriptFeatures","hyperscriptFeatures","get","set","addFeatures","owner","parentElement","makeContext","feature","hyperscriptTarget","lexer","iterators","me","target","body","src","hyperscript","initElement","closest","disableSelector","internalData","getInternalData","initialized","script","hyperScript","setTimeout","console","stack","internalDataMap","getElementScope","scopeName","behavior","flatGet","property","getter","componentValue","typeCheck","typeString","nullOk","prototype","slice","implicitLoop","processNode","getScriptSelector","HyperscriptModule","mod","_this","module","id","EventTarget","evaluateNoPromise","map","attribute","join","resolveSymbol","fromMetaContext","fromContext","setSymbol","elementScope","findNext","resolveNext","convertValue","converted","dynamicResolver","converter","handlingFinally","registerHyperTrace","errorHandler","handlingError","errorSymbol","currentException","resolvedNext","finallyHandler","onHalt","resolveProperty","resolveAttribute","resolveStyle","style","resolveComputedStyle","getComputedStyle","getPropertyValue","assignToNamespace","nameSpace","propertyName","newRoot","thrown","trace","caller","traceMap","Map","print","logger","maxLen","Math","max","displayName","traceElt","padEnd","getHyperTrace","nullCheck","isEmpty","doesExist","node","Node","rv","Document","ShadowRoot","getEventQueueFor","onFeature","eventQueuesForElt","eventQueues","eventQueueForFeature","queue","executing","hyperscriptUrl","sloppyContains","container","includes","sloppyMatches","toMatch","parseSendCmd","cmdType","details","toExpr","sendCmd","to","parseConversionInfo","conversion","expr","stringToken","rawValue","innerTokens","returnStr","tokenArr","t","numberToken","elementId","templateValue","getElementById","TemplatedQueryElementCollection","templateParts","_this2","elements","filter","Element","el","dataset","hsQueryId","removeAttribute","queryTokens","queryValue","outerVal","innerValue","beingTold","styleProp","startsWith","keyExpressions","valueExpressions","keys","returnVal","fields","_namedArgList_","scope","eltPrefix","booleanLiteral","arg1","_context","rootVal","childOfUrRoot","urRoot","attributeElt","propertyAccess","possessivesDisabled","apostrophe","targetElt","results","within","rootElt","functionCall","argExressions","rootRoot","hyperfunc","argVals","_ctx","andBefore","andAfter","firstIndex","secondIndex","arrayIndex","STRING_POSTFIXES","stringPosfix","postfix","timeFactor","time","factor","typeName","booped","originalEvaluate","logValue","constructor","log","scanForwardArray","array","wrap","first","forwardSearch","thing","withinElt","inSearch","inElt","wrapping","operator","reverse","compareDocumentPosition","DOCUMENT_POSITION_PRECEDING","scanForwardQuery","DOCUMENT_POSITION_FOLLOWING","scanBackwardsQuery","rhs","rhsVal","floor","random","mathOp","initialMathOp","lhs","lhsVal","comparisonToken","hasRightValue","logicalOp","initialLogicalOp","features","install","parseEventArgs","every","events","startCountToken","startCount","endCountToken","endCount","unbounded","intersectionSpec","mutationSpec","elsewhere","inExpr","debounceTime","throttleTime","execCount","on","debounced","lastExec","queueLast","queueFirst","queueNone","eventQueueInfo","queued","err","hypertrace","eventSpec","targets","MutationObserver","mutationList","observer","observe","IntersectionObserver","entries","entry","isIntersecting","addEventListener","listener","isConnected","removeEventListener","eventValue","initialCtx","inElement","clearTimeout","now","nameVal","funcName","functionFeature","argumentVal","callingCommand","promise","theResolve","theReject","returnValue","hypername","setCmd","setFeature","initFeature","path","formalParams","hs","innerArgs","installFeature","behaviorPath","behaviorNamespace","Function","jsSourceStart","jsLastToken","funcNames","expectFunctionDeclaration","exposedFunctionNames","jsSource","jsBody","function","inputs","inp","input","actualResult","slot","tellCmd","index","originalBeingTold","lookahead","resolved","eventInfo","_this3","once","timeValue","_this4","separator","parseReturnFunction","returnAValue","returnCmd","keepExecuting","bubbling","haltDefault","exit","stopPropagation","preventDefault","exprs","withExpr","logCmd","throwCmd","parseCallOrGet","callCmd","tagname","classes","re","exec","trim","createElement","classList","lookAhead","realRoot","pseudoCommand","makeSetter","symbolWrite","attributeWrite","styleWrite","arrayWrite","valueToSet","setAttribute","setter","defaultCmd","obj","objectLiteral","trueBranch","falseBranch","ifCmd","exprValue","parseRepeatExpression","startedWithForToken","innerStartToken","identifierToken","whileExpr","isUntil","forever","times","indexIdentifier","loop","last","waitATick","repeatCmd","until","whileValue","iteratorInfo","keepLooping","loopVal","eventFired","nextValFromIterator","done","repeatInit","targetExpr","implicitResultSymbol","innerHTML","amount","implicitIncrementOp","targetValue","newValue","implicitDecrementOp","url","conversionInfo","fetchCmd","argExpressions","abortController","AbortController","abortListener","abort","signal","finished","timeout","fetch","resp","resultDetails","response","json","text","scripts","res","script_values","fn","metaConfig","querySelector","jString","msg","parseJSON","content","documentElement","readyState","internals","defaultTransition","conversions","onExpr","settleCommand","transitionStarted","r","cssDeclaration","classRefs","when","remove","attrRef","cssText","stringParts","opencurly","tok","part","idx","elementExpr","fromExpr","removeChild","visibility","hideShowStrategy","resolveStrategy","between","classRef2","toggleCmd","toggle","HIDE_SHOW_STRATEGIES","display","originalDisplay","removeProperty","opacity","parseShowHideTarget","currentTokenValue","configDefault","defaultHideShowStrategy","strategies","hideShowStrategies","putInto","valueToPut","HTMLDocument","firstChild","append","parsePseudopossessiveTarget","forExpr","forElt","eltColl","clazz","operationToken","operation","rootExpr","putCmd","before","after","prepend","targetsExpr","properties","over","using","transition","promises","initialTransition","computedStyles","initialStyles","initalStyles","fromVal","toVal","propsToMeasure","rect","getBoundingClientRect","scroll","top","scrollTop","left","scrollLeft","topMax","scrollTopMax","leftMax","scrollLeftMax","height","scrollHeight","width","scrollWidth","x","y","right","bottom","bounds","parentSearch","closestExpr","back","newWindow","verticalPosition","horizontalPosition","plusOrMinus","offset","smoothness","scrollOptions","block","inline","goCmd","window","history","open","location","href","boundingRect","scrollShim","finalOffset","zIndex","MIN_SAFE_INTEGER","appendChild","scrollIntoView","getInputInfo","appendValue","URLSearchParams","info","checked","selected","toHTML","item","HTMLElement","outerHTML","frag","createDocumentFragment","temp","web"],"mappings":"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"}